<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"}>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1b" />

    <meta name="description" content="Lab 0: Rustlings">

    
        <title>Lab 0: Rustlings | OS Labs</title>
    

    
    <style>
        :root {
          --background: #ffffff;
        }
        @media (prefers-color-scheme: dark) {
          :root {
            --background: #1b1b1b;
          }
        }
        html {
            background-color: var(--background);
        }
        body {
            background-color: var(--background);
        }
    </style>

    
    <link rel="stylesheet" type="text/css" href="/style.min.375e5ed55aac1492efe66cf6fd686d0af88cb56b12d6bafab6571d3b39c73883.css" media="all">
  </head>

  <body>
        
        <nav>
          <ul class="menu">
            
                <li><a tabindex="-1" class="menu-link" href="/">Home</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/tags">Tags</a></li>
            
          </ul>
        </nav>
        




<div id="single-header">
  <h1>
    Lab 0: Rustlings
  </h1>
  <div id="single-meta">
    
    
        <span class="datesub">Jan 7, 2020</span>
      
<span id="tags">
  &nbsp;&nbsp;
   <span>
    <a href="//localhost:1313/tags/lab/">#lab</a>
  </span>&nbsp;</span>


  </div>
</div>



<aside class="hidden lg:block toc " id="tableOfContentContainer">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a>
      <ul>
        <li><a href="#overview">Overview</a></li>
      </ul>
    </li>
    <li><a href="#rustlings">Rustlings</a></li>
    <li><a href="#assignment-submission">Assignment Submission</a>
      <ul>
        <li><a href="#grading-policy">Grading Policy</a></li>
      </ul>
    </li>
  </ul>
</nav>
</aside>



<main><ul>
<li><strong>Handed out:</strong> Tuesday, January 7, 2020</li>
<li><strong>Due:</strong> Monday, January 20, 2020</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Welcome to CS3210! We&rsquo;re really excited that you&rsquo;ve decided to
join us for this inaugural incarnation. We hope you have as much
fun taking this class as we&rsquo;ve had developing it! And, of course,
we hope you learn a ton.</p>
<p>We&rsquo;re hoping to do things a little differently in CS3210 than the
norm. In particular, we want <em>you</em> to write the majority of the
code, and we want your code to execute on <em>real</em> hardware, doing
<em>real</em> things. There&rsquo;s going to be very little scaffolding
provided for you, and all of your code will target and run on the
Raspberry Pi 3/B/B+, a quad-core ARMv8 Cortex-A53 based embedded
platform.</p>
<p>Unlike last serveral years,
we&rsquo;ll be programming a toy OS
in <a href="https://www.rust-lang.org/en-US/"  target="_blank" rel="noreferrer nofollow">Rust</a>
,
&ldquo;a systems programming language that runs blazingly fast, prevents segfaults,
and guarantees thread safety.&rdquo;
You can think of Rust as a
successor to C and C++, but it&rsquo;s more useful to think of it as a
brand new language with new concepts. Don&rsquo;t try to program in Rust
as if it&rsquo;s C, C++, Java, or any other language you&rsquo;re used to.
Instead, see it as an opportunity to learn a new way to write
software - a new <em>rusty</em> way. By the end of the term, we think
you&rsquo;ll agree that Rust helps you write more correct, more
reliable, and importantly more secure software,
which are the key properties for operating systems!</p>
<p>You&rsquo;ll be writing a lot of code in CS3210, though we think that
the majority of your time will be spent thinking about what needs
to happen. We expect that most assignments will take about 15-20
hours a week to complete, which means you should, under no circumstance,
procrastinate in CS3210.
Start early, ask questions, visit us at the office hours,
and importantly have fun - you&rsquo;ll learn much more if you give yourself
a chance to think through hard problems.</p>
<p>We&rsquo;re here to answer any and all questions. Please don&rsquo;t hesitate
to reach out to us. Best of luck!</p>
<h3 id="overview">Overview</h3>
<p>Mastering a programming language takes time.
In fact, truly mastering a single programming language
takes <em>long</em> time, perhaps our lifetime.
In other words, it&rsquo;s unrealistic to assume
that we become a true master of Rust in a week</p>
<ul>
<li>but we all hope we can start tinkering anything with Rust
at the end of this semester.</li>
</ul>
<p>As a warm up, we will spend sometime
to understand syntactic as well as semantic
foundation of the Rust programming language
by answering a series of questions we prepared.</p>
<p>To get set up your environment,
let&rsquo;s first install required dependencies
and the Rust ecosystems, namely <code>rustc</code> and <code>cargo</code>.
We assume that you are doing the assignments
on a latest LTS Ubuntu distribution (i.e., Ubuntu 18.04 LTS).
If you are not running Ubuntu natively,
please check the <a href="tools.html" >Tool</a>
 page
to prepare a Ubuntu virtual machine.
Also if you are not familiar with <code>git</code>,
please first check
<a href="https://git-scm.com/book/en/v2"  target="_blank" rel="noreferrer nofollow">Pro Git Book</a>
.</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ git clone https://github.com/sslab-gatech/cs3210-rustos-public.git --origin skeleton rustos
</span></span><span style="display:flex;"><span>$ <span style="color:#91d7e3">cd</span> rustos
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6e738d;font-style:italic"># This script automatically setup the environment</span>
</span></span><span style="display:flex;"><span>$ bin/setup.sh
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ <span style="color:#91d7e3">export</span> <span style="color:#f4dbd6">PATH</span><span style="color:#91d7e3;font-weight:bold">=</span><span style="color:#f4dbd6">$HOME</span>/.cargo/bin:<span style="color:#f4dbd6">$PATH</span>
</span></span><span style="display:flex;"><span>$ rustc --version
</span></span><span style="display:flex;"><span>rustc 1.37.0-nightly <span style="color:#91d7e3;font-weight:bold">(</span>0af8e872e 2019-06-30<span style="color:#91d7e3;font-weight:bold">)</span>
</span></span></code></pre></div><p>In the repository, we try hard to keep everything in place</p>
<ul>
<li>no additional download or dependencies. It looks like:</li>
</ul>
<pre tabindex="0"><code class="language-none" data-lang="none">.
├── bin : common binaries/utilities (e.g., objdump for aarch64)
├── doc : reference documents
└── tut : tutorial/practices (i.e., no further reuse for later labs)
    └── 0-rustlings : this contains files for lab0
</code></pre><h2 id="rustlings">Rustlings</h2>
<p>Our goal of lab0 is to guide you to read
from <a href="https://doc.rust-lang.org/rust-by-example/hello.html"  target="_blank" rel="noreferrer nofollow">Chapter 1</a>
 to
<a href="https://doc.rust-lang.org/rust-by-example/error.html"  target="_blank" rel="noreferrer nofollow">Chapter 18</a>

of <a href="https://doc.rust-lang.org/rust-by-example/index.html"  target="_blank" rel="noreferrer nofollow">Rust By Example</a>
.</p>
<p>To check your understanding,
we will use <a href="https://github.com/rust-lang/rustlings/"  target="_blank" rel="noreferrer nofollow">Rustlings</a>
,
which is a neat way
to get familiarized with Rust
by solving a series of <em>simple</em> exercises.
It provides an interactive session of training
by comprehending the compiler error messages
and resolving it.
While doing exercises,
you would like to read various chapters of
<a href="https://doc.rust-lang.org/book/index.html"  target="_blank" rel="noreferrer nofollow">The Rust Book</a>
.
You can also find more pointers on Rust
in the course&rsquo;s reference page.</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ <span style="color:#91d7e3">cd</span> tut/0-rustlings
</span></span><span style="display:flex;"><span>$ ./rustlings <span style="color:#91d7e3">help</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>SUBCOMMANDS:
</span></span><span style="display:flex;"><span>    <span style="color:#91d7e3">help</span>      Prints this message or the <span style="color:#91d7e3">help</span> of the given subcommand<span style="color:#91d7e3;font-weight:bold">(</span>s<span style="color:#91d7e3;font-weight:bold">)</span>
</span></span><span style="display:flex;"><span>    hint      Returns a hint <span style="color:#c6a0f6">for</span> the current exercise
</span></span><span style="display:flex;"><span>    run       Runs/Tests a single exercise
</span></span><span style="display:flex;"><span>    verify    Verifies all exercises according to the recommended order
</span></span><span style="display:flex;"><span>    watch     Reruns <span style="color:#a6da95">`</span>verify<span style="color:#a6da95">`</span> when files were edited
</span></span></code></pre></div><p>To start your exercise,
you can invoke the <code>watch</code> command
that guides you which exercise to work on
in a proper order:</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ ./rustlings watch
</span></span></code></pre></div><p>If you&rsquo;d like, you can also do each exercise (files in <code>exercises/</code>)
by invoking <code>./rustling run [name]</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ ./rustlings run variables1
</span></span><span style="display:flex;"><span>! Compilation of exercises/variables/variables1.rs failed! Compiler error message:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>error<span style="color:#91d7e3;font-weight:bold">[</span>E0425<span style="color:#91d7e3;font-weight:bold">]</span>: cannot find value <span style="color:#a6da95">`</span>x<span style="color:#a6da95">`</span> in this scope
</span></span><span style="display:flex;"><span>    --&gt; exercises/variables/variables1.rs:12:5
</span></span><span style="display:flex;"><span>    |
</span></span><span style="display:flex;"><span> <span style="color:#f5a97f">12</span> |     <span style="color:#f4dbd6">x</span> <span style="color:#91d7e3;font-weight:bold">=</span> 5;
</span></span><span style="display:flex;"><span>    |     ^ not found in this scope
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>error<span style="color:#91d7e3;font-weight:bold">[</span>E0425<span style="color:#91d7e3;font-weight:bold">]</span>: cannot find value <span style="color:#a6da95">`</span>x<span style="color:#a6da95">`</span> in this scope
</span></span><span style="display:flex;"><span>    --&gt; exercises/variables/variables1.rs:13:36
</span></span><span style="display:flex;"><span>    |
</span></span><span style="display:flex;"><span> <span style="color:#f5a97f">13</span> |     println!<span style="color:#91d7e3;font-weight:bold">(</span><span style="color:#a6da95">&#34;x has the value {}&#34;</span>, x<span style="color:#91d7e3;font-weight:bold">)</span>;
</span></span><span style="display:flex;"><span>    |                                    ^ not found in this scope
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>error: aborting due to <span style="color:#f5a97f">2</span> previous errors
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>For more information about this error, try <span style="color:#a6da95">`</span>rustc --explain E0425<span style="color:#a6da95">`</span>.
</span></span></code></pre></div><p>If you find the exercise too difficult,
ask rustlings for hints of the exercise, like below:</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ rustlings hint variables1
</span></span><span style="display:flex;"><span>Hint: The declaration on line <span style="color:#f5a97f">12</span> is missing a keyword that is needed in Rust
</span></span><span style="display:flex;"><span>to create a new variable binding
</span></span></code></pre></div><p>To complete this assignment, <code>./rusting verify</code> should say
all the prepared exercises are successfully completed!</p>
<h2 id="assignment-submission">Assignment Submission</h2>
<p>We are going to use <a href="https://github.gatech.edu"  target="_blank" rel="noreferrer nofollow">Georgia Tech&rsquo;s GitHub</a>

for the assignment submission in CS3210.
After logging into the system,
<a href="https://help.github.com/en/github/getting-started-with-github/create-a-repo"  target="_blank" rel="noreferrer nofollow">create a repository</a>
 named <code>rustos</code>.
When creating the repository, <strong>make it private</strong>
and <strong>do not initialize the repository with a README</strong>.
Next, give TAs&rsquo; accounts access to your repository for the grading purpose.
You should add us in <code>Settings &gt; Collaborators</code> in your repository menu.</p>
<ul>
<li>Yechan Bae (ybae38)</li>
<li>Sujin Park (spark800)</li>
<li>Mansour Alharthi (malharthi9)</li>
<li>Taesoo Kim (tkim92)</li>
</ul>
<p>Once you have created the repository, <strong>inform us via</strong>
<a href="https://forms.gle/5nz7F3DoWGELjtev8"  target="_blank" rel="noreferrer nofollow">Google Form</a>
.</p>
<p>To submit your code for lab0,
push a commit to the GitHub repository with a tag named <code>lab0-done</code>.
We will fetch the assignment code from your repository on each deadline.
The following git command samples might be helpful.</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#6e738d;font-style:italic"># connect your local repository to GitHub</span>
</span></span><span style="display:flex;"><span>$ git remote add origin https://github.gatech.edu/<span style="color:#91d7e3;font-weight:bold">[</span>id<span style="color:#91d7e3;font-weight:bold">]</span>/rustos
</span></span><span style="display:flex;"><span>$ git push -u origin master
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6e738d;font-style:italic"># make a commit and publish the update</span>
</span></span><span style="display:flex;"><span>$ git status
</span></span><span style="display:flex;"><span>$ git add -A
</span></span><span style="display:flex;"><span>$ git commit -a -m <span style="color:#a6da95">&#34;yay, lab0 done!&#34;</span>
</span></span><span style="display:flex;"><span>$ git push
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6e738d;font-style:italic"># submit lab0</span>
</span></span><span style="display:flex;"><span>$ git tag lab0-done
</span></span><span style="display:flex;"><span>$ git push --tags
</span></span></code></pre></div><h3 id="grading-policy">Grading Policy</h3>
<p>Your score will be simply calculated based
on the submission date of the &ldquo;completed&rdquo; assignment.
The meaning of &ldquo;completion&rdquo; is for your repository
to be <strong>tagged</strong> as &ldquo;labN-done&rdquo; (e.g., lab0-done).
If your code in the repo
passes all test cases
provided as part of the assignment <strong>on time</strong>,
you will get the maximum score (i.e., 100) for the corresponding lab.
If you are late in submitting the completed assignment,
your score of the lab
will be <code>max(0, 100*[#passes/#testcases] - [#late-day]*10)</code>, in theory.</p>
<p>However, we give <strong>a week</strong> (7 days in total for all labs)
of a grace period, which you can use without even letting
us know! For example,
if you are one-day late in submitting the first lab
(i.e., the completed lab0),
you still get 100 points for the lab
but your grace period is <em>first</em> reduced to 6 days.
Once you don&rsquo;t have any grace period left,
the above rule for the lab effectively takes place.
For example, if you don&rsquo;t have any grace period
but again late in submitting the lab one day,
your score would be <code>max(0, 100 - 1*10)</code>, so <code>90</code>
for the completed lab.</p>
<p>We will regularly fetch your repository after the initial deadline,
and your score and the grace period will be automatically updated on canvas.
Please <a href="http://headstrong.gtisc.gatech.edu:8080/info.html#staff-ta"  target="_blank" rel="noreferrer nofollow">send us an email</a>

if you made a late change to the assignment
and your score had not updated for a week.</p>
<p>We really hope <em>all</em> the students in this class get A!</p>
</main>




<br>

<footer>

<script defer>
  document.addEventListener("keydown", function (e) {
    if (document.activeElement.isContentEditable) {
      return false;
    }
    if (document.activeElement.tagName == "INPUT") {
      return false;
    }
    if (e.altKey || e.ctrlKey || e.shiftKey) {
      return false;
    }
    var key = e.key;
    if (key === "h") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/";
    } else if (key === "t") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = `https://${location.hostname}/tags`;
    } else if (key === "i") {
      e.preventDefault();
      e.stopPropagation();
      const inputs = document.querySelectorAll("input");
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].offsetParent !== null) {
          inputs[i].selectionStart = inputs[i].selectionEnd =
            inputs[i].value.length;
          inputs[i].focus();
          break;
        }
      }
    }
    return false;
  });
</script>


<script defer>
  function throttle(fn, wait) {
    var time = Date.now();
    return function () {
      var now = Date.now()
      if (time + wait - now < 0) {
        fn();
        time = now;
      }
    };
  }

  function scrollHandler() {
    const anchors = Array.from(document.querySelectorAll("body h2, body h3"));

    function scrollCallback() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      
      for (var i = 0; i < anchors.length; i++) {
        var anchorId = anchors[i].getAttribute("id");
        var link = document.querySelector(
          'nav ul li a[href="#' + anchorId + '"]',
        );
        if (link) {
          link.classList.remove("active-toc");
        }
      }

      
      for (var i = anchors.length - 1; i >= 0; i--) {
        var offsetTop = anchors[i].offsetTop;
        if (scrollTop > offsetTop - 75) {
          var anchorId = anchors[i].getAttribute("id");
          var link = document.querySelector(
            'nav ul li a[href="#' + anchorId + '"]',
          );
          if (link) {
            link.classList.add("active-toc");
            break;
          }
        }
      }
    }

    window.addEventListener(
      "scroll",
      throttle(scrollCallback, 300),
    );
  }
  setTimeout(scrollHandler, 100);
</script>

<script defer>
  function addCopyButtonToCodeBlocks() {
    
    const codeBlocks = document.querySelectorAll('code[class^="language-"]');

    codeBlocks.forEach((codeBlock) => {
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-code-button");
      copyButton.innerHTML = "copy";

      
      copyButton.addEventListener("click", () => {
        
        const elements = codeBlock.querySelectorAll(".cl");
        let codeToCopy = "";
        elements.forEach((element) => {
          codeToCopy += element.innerText;
        });
        navigator.clipboard.writeText(codeToCopy);

        
        copyButton.innerHTML = "copied!";
        setTimeout(() => {
          copyButton.innerHTML = "copy";
        }, 1500);
      });

      
      codeBlock.parentNode.before(copyButton);
    });
  }
  setTimeout(function () {
    addCopyButtonToCodeBlocks();
  }, 100);
</script>

<script>
window.store = {
    
    "\/\/localhost:1313\/post\/": {
        "title": "Posts",
        "tags": [],
        "content": "", 
        "url": "\/\/localhost:1313\/post\/"
    },
    
    "\/\/localhost:1313\/": {
        "title": "",
        "tags": [],
        "content": " ", 
        "url": "\/\/localhost:1313\/"
    },
    
    "\/\/localhost:1313\/tags\/lab\/": {
        "title": "Lab",
        "tags": [],
        "content": "", 
        "url": "\/\/localhost:1313\/tags\/lab\/"
    },
    
    "\/\/localhost:1313\/post\/lab2\/": {
        "title": "Lab 2: Shell and Bootloader",
        "tags": ["Lab",],
        "content": " Handed out: Tuesday, January 28, 2020 Due: Monday, February 10, 2020 Introduction In this assignment, you will write useful utilities, libraries, and a simple shell for your Raspberry Pi. You\u0026rsquo;ll also write generic drivers for GPIO, UART , and the built-in timer. Finally, you\u0026rsquo;ll write a \u0026ldquo;bootloader\u0026rdquo; using your new drivers that loads program binaries over UART using the XMODEM protocol and executes them.\nGetting the Skeleton Code To get the skeleton code for lab2, fetch the updates from our git repository to your development machine.\n$ git fetch skeleton $ git merge skeleton/lab2 This is the directory structure of our repository. The directories you will be working on this assignment are marked with *.\n. ├── bin : common binaries/utilities ├── doc : reference documents ├── ext : external files (e.g., resources for testing) ├── tut : tutorial/practices │ ├── 0-rustlings │ ├── 1-blinky │ └── 2-shell : questions for lab2 * ├── boot : bootloader * ├── kern : the main os kernel * └── lib : required libraries ├── pi * ├── shim ├── stack-vec * ├── ttywrite * ├── volatile * └── xmodem * Please resolve conflict if you have and proceed to the next phase.\nWe recommend the following directory structure for your assignments. Confirm that your directories are properly laid out by running make inside the kern directory now. If all is well, the command will return successfully. If everything is good, feel free to explore the contents of the repository.\nThis and future assignments include writing questions that you must respond to. Here\u0026rsquo;s an example of such question:\nHow do you set other GPIO pins? (1-blinky)\nIn assignment 1-blinky, you enabled GPIO pin 16 as an output and then repeatedly set and cleared it by writing to registers GPFSEL1, GPSET0, and GPCLR0. Which three registers would you write to to do the same for GPIO pin 27? Which physical pin on the Raspberry Pi maps to GPIO pin 27?\nThe word in a parenthesis of the question indicates the name of a file located inside questions/ directory relative to the lab name in which the question is being asked. For instance, every questions in this Lab2: Shell and Bootloader should be answered in tut/2-shell/questions/ subdirectory. Note that we have pre-generated empty files for every question.\nPractice responding to questions now by answering the 1-blinky question above.\nPhase 1: Oxidation In this phase, you will write two libraries, one command-line utility, and review one library. You will be working in the stack-vec, volatile, ttywrite, and xmodem skeleton subdirectories located in lib directory.\nAll projects are being managed with Cargo. You will find the following cargo commands useful:\ncargo build - build an application or library cargo test - test an application or library cargo run - run an application cargo run -- $flags - run an application and pass arbitrary flags to it For more information on using Cargo and how Cargo works, see the Cargo Book .\nSubphase A: StackVec One important facility that operating systems provide is memory allocation. When a C, Rust, Java, Python, or just about any application calls malloc() and malloc() has run out of memory from the operating system, a system call is eventually made to request additional memory. The operating system determines if there is memory available, and if so, fulfills the request for memory.\nMemory allocation is a complicated story.\nIn practice, modern operating systems like Linux have a complicated relationship with memory allocation. For instance, as an optimization, most requests for memory allocation are only \u0026ldquo;virtually\u0026rdquo; handled: no physical memory is actually allocated until the application tries to use the newly allocated memory. Nonetheless, most operating systems aim to provide the illusion that they are allocating memory in the simplistic manner we\u0026rsquo;ve described. Operating systems are master liars.\nHeap-allocated structures like Vec, String, and Box internally call malloc() to allocate memory as necessary. This means that these structures require operating system support to function. In particular, they require the operating system to support memory allocation. We haven\u0026rsquo;t yet started writing our operating system, so clearly there\u0026rsquo;s no memory allocation support for our tiny bare-metal programs to make use of. As such, we can\u0026rsquo;t use heap-allocated structures like Vec until our operating system is further along.\nThis is a real shame because Vec is a nice abstraction! It allows us to think about pushing and poping elements without having to keep track of memory ourselves. How we can get the benefits of the Vec abstraction without supporting memory allocation?\nOne common technique is to pre-allocate memory and then hand that memory to a structure to abstract away. Some ways to pre-allocate memory include using static declarations to set apart memory in the static section of a binary or through stack allocations from local variable declarations. In any case, the allocations is of a fixed, predetermined size.\nIn this subphase, you will implement the StackVec structure, a structure that exposes a Vec-like API when given pre-allocated memory. You will use the StackVec type later in phase 2 when implementing a shell for your Raspberry Pi. You will work in the lib/stack-vec skeleton subdirectory. The subdirectory contains the following files:\nCargo.toml - configuration file for Cargo src/lib.rs - where you will write your code src/tests.rs - tests that will run when cargo test is called The StackVec Interface A StackVec\u0026lt;T\u0026gt; is created by calling StackVec::new(), passing in a mutable slice to values of any type T. The StackVec\u0026lt;T\u0026gt; type implements many of the methods that Vec implements and is used in much the same way. Here\u0026rsquo;s an example of a StackVec\u0026lt;u8\u0026gt; being used:\nlet mut storage = [0u8; 10]; let mut vec = StackVec::new(\u0026amp;mut storage); for i in 0..10 { vec.push(i * i).expect(\u0026#34;can push 10 times\u0026#34;); } for (i, v) in vec.iter().enumerate() { assert_eq!(*v, (i * i) as u8); } let last_element = vec.pop().expect(\u0026#34;has elements\u0026#34;); assert_eq!(last_element, 9 * 9); We\u0026rsquo;ve declared the StackVec structure for you already:\npub struct StackVec\u0026lt;\u0026#39;a, T: \u0026#39;a\u0026gt; { storage: \u0026amp;\u0026#39;a mut [T], len: usize } Understanding StackVec The following questions test your understanding about the StackVec interface:\nWhy does push return a Result? (push-fails)\nThe push method from Vec in the standard library has no return value, but the push method from our StackVec does: it returns a Result indicating that it can fail. Why can StackVec::push() fail where Vec::push() does not?\nWhy is the 'a bound on T required? (lifetime)\nstruct StackVec\u0026lt;\u0026#39;a, T\u0026gt; { buffer: \u0026amp;\u0026#39;a mut [T], len: usize } Rust automatically enforces the bound T: 'a and will complain if type T lives shorter than the lifetime 'a. For instance, if T is \u0026amp;'b str and 'b is strictly shorter than 'a, Rust won\u0026rsquo;t allow you to create the instance of StackVec\u0026lt;'a, \u0026amp;'b str\u0026gt;.\nWhy is the bound required? What could go wrong if the bound wasn\u0026rsquo;t enforced by Rust?\nWhy does StackVec require T: Clone to pop()? (clone-for-pop)\nThe pop method from Vec\u0026lt;T\u0026gt; in the standard library is implemented for all T, but the pop method from our StackVec is only implemented when T implements the Clone trait. Why might that be? What goes wrong when the bound is removed?\nImplementing StackVec Implement all of the unimplemented!() StackVec methods in stack-vec/src/lib.rs. Each method is documented in the source code. We have also provided tests in src/tests.rs that help ensure that your implementations are correct. You can run these tests with cargo test. You\u0026rsquo;ll also need to implement the Deref, DerefMut, and IntoIterator traits for StackVec as well as the IntoIterator trait for \u0026amp;StackVec for all of the cargo test tests to pass. Once you feel confident that you implementation is correct and have answered this subphase\u0026rsquo;s questions, proceed to the next subphase.\nWhich tests make use of the Deref implementations? (deref-in-tests)\nRead through the tests we have provided in src/tests.rs. Which tests would fail to compile if the Deref implementation did not exist? What about the DerefMut implementation? Why?\nOur unit tests are incomplete!\nOur unit tests provide a baseline truth, but they are not complete! We will run additional tests when we grade your assignment. You may wish to find the gaps in our tests and add additional tests of your own to fill them.\nSubphase B: volatile In this subphase, you will learn about volatile memory accesses, read the source code in the volatile skeleton subdirectory, and answer questions related to the source code. You won\u0026rsquo;t be writing any code in this subphase.\nLike operating systems, compilers are masters at making things appear as if they\u0026rsquo;re doing what you think they\u0026rsquo;re doing when in reality, they\u0026rsquo;re really doing something entirely different for the sake of optimization. One such optimization is dead-access elimination: compilers remove memory accesses (reads and writes) when they can prove doing so has no observable effect on the program\u0026rsquo;s execution. For instance, consider the following program:\nfn f() { let mut x = 0; let y = \u0026amp;mut x; *y = 10; } The compiler can completely eliminate the write to *y by reasoning that *y is never read after it\u0026rsquo;s written. The compiler concludes that as a result, the write cannot possibly effect the program, and eliminates it in the compiled binary. For the same reason, it can then proceed to eliminate the declaration for y, the declaration for x, and calls to f() entirely.\nThese kinds of optimizations are almost exclusively beneficial: they speed up our programs without affecting their outcome. But sometimes these optimizations can have unintended consequences. Say, for example, that y was pointing to a write-only memory-mapped register. Then, writes to *y will have observable effects without having to read *y thereafter. If the compiler is not aware of this, it will optimize away these writes, and our program will not function correctly.\nHow can we force the compiler to keep around reads and writes that appear to have no effects at the source code level? This is where volatile memory accesses come in: the compiler promises not to optimize away volatile memory accesses. So if we want to ensure a read or write occurs at runtime, we must perform a volatile memory access.\nRusty volatile In Rust, we use the read_volatile and write_volatile methods to perform volatile reads and writes to a raw pointer.\nWhat\u0026rsquo;s a raw pointer?\nBy now you\u0026rsquo;re familiar with references (\u0026amp;T and \u0026amp;mut T). A raw pointer in Rust (*const T and *mut T) is a \u0026ldquo;reference\u0026rdquo; that isn\u0026rsquo;t tracked with lifetimes by Rust\u0026rsquo;s borrow checker. Because of this, read or writes to these pointers may be invalid, just as in C. Rust considers them unsafe, and code that reads or writes them must be annotated with unsafe to indicate this. You can read more about raw pointers in the rustdocs .\nCalling read_volatile and write_volatile every time we want to perform a volatile read or write is error prone and frustrating. Thankfully Rust provides us the tools to make this easier and safer. Ideally we can simply declare a pointer as volatile (as in C) and ensure that every read or write thereafter is volatile. Even better, we should be able declare a pointer as read-only, write-only (unlike in C), or read/write and ensure only the appropriate memory accesses can be made.\nIntroducing Volatile, ReadVolatile, WriteVolatile, and UniqueVolatile The volatile crate in the volatile/ skeleton subdirectory implements these four types that allow us to do just this. Read the documentation for these types now by running cargo doc --open inside of the volatile/ directory.\nWhy does Unique\u0026lt;Volatile\u0026gt; exist? (unique-volatile)\nBoth Volatile and Unique\u0026lt;Volatile\u0026gt; allow read/write volatile accesses to an underlying pointer. According to the documentation, what is the difference between these two types?\nNow open the source code in src/lib.rs, src/traits.rs, and src/macros.rs. Read through the source code to the best of your abilities. When you\u0026rsquo;re ready, answer the following questions. Once you have answered these questions, you\u0026rsquo;re ready to move on to the next subphase.\nWhat\u0026rsquo;s with #[repr(C)]?\nThe #[repr(C)] annotation forces Rust to lay out the structure\u0026rsquo;s fields in the same way that C would. In general, Rust optimizes the order and padding between fields of structures in an unspecified way. When we cast a raw address to a pointer to a structure, we typically have a very specific memory layout in mind. The #[repr(C)] annotation lets us confide that Rust will arrange the structure as we intend it to, not as it wishes.\nHow are read-only and write-only accesses enforced? (enforcing)\nThe ReadVolatile and WriteVolatile types make it impossible to write and read, respectively, the underlying pointer. How do they accomplish this?\nWhat do the macros do? (macros)\nWhat do the readable!, writeable!, and readable_writeable! macros do?\nSubphase C: xmodem In this subphase, you will implement the XMODEM file transfer protocol in the xmodem library in the xmodem/ skeleton subdirectory. You will primarily be working in xmodem/src/lib.rs.\nXMODEM is a simple file transfer protocol originally developed in 1977. It features packet checksums, cancellation, and automatic retries. It is widely implemented and used for transfers through serial interfaces. Its best feature, however, is its simplicity. For more about its history, see the XMODEM Wikipedia article .\nWe will use the XMODEM protocol to transfer files to the Raspberry Pi. While we could use existing implementations of the XMODEM protocol to send data to the Pi, we will still need to write our own receiver. So, while we\u0026rsquo;re at it, we\u0026rsquo;ll be implementing XMODEM transmission as well.\nThe Protocol The XMODEM protocol is described in detail in the Understanding The X-Modem File Transfer Protocol txt file. We describe it again here, for posterity.\nDo not base your implementation off of Wikipedia\u0026rsquo;s explanation!\nWhile Wikipedia\u0026rsquo;s explanation is helpful at a high level, many of the details presented there are different from the protocol we\u0026rsquo;ll be implementing here. As such, do not use the article as a reference for this subphase.\nXMODEM is a binary protocol: bytes are sent and received in the raw. It is also \u0026ldquo;half duplex\u0026rdquo;: at any point in time, either the sender or receiver is sending data, but never both. Finally it is packet-based: data is separated into 128 byte chunks known as packets. The protocol dictates which bytes are sent when, what they mean, and how they\u0026rsquo;re interpreted.\nFirst, we define a few constants:\nconst SOH: u8 = 0x01; const EOT: u8 = 0x04; const ACK: u8 = 0x06; const NAK: u8 = 0x15; const CAN: u8 = 0x18; To start the file transfer, the receiver sends a NAK byte while the sender waits for a NAK byte. Once the sender has received the NAK byte, packet transmission begins. The receiver only sends a NAK byte to begin the file transfer, not once for every packet.\nOnce file transfer has begun, each packet\u0026rsquo;s transmission and reception is identical. Packets are numbered in sequential order starting at 1 and wrap around to 0 after 255.\nXMODEM protocol diagram To send a packet, the sender:\nSends an SOH byte.\nSends the packet number.\nSends the 1s complement of the packet number (255 - $packet_number).\nSends the packet itself.\nSends the packet checksum.\nThe checksum is the sum of all of the bytes in the packet mod 256. Reads a byte from the receiver.\nIf the byte is NAK, transmission for the same packet is retried up to 10 times. If the byte is ACK, the next packet is sent. The receive a packet, the receiver performs the inverse:\nWaits for an SOH or EOT byte from the sender.\nIf a different byte is received, the receiver cancels the transfer. If an EOT byte is received, the receiver performs end of transmission. Reads the next byte and compares it to the current packet number.\nIf the wrong packet number is received, the receiver cancels the transfer. Reads the next byte and compares it to the 1s complement of the packet number.\nIf the wrong number is received, the receiver cancels the transfer. Reads a packet (128 bytes) from the sender.\nComputes the checksum for the packet.\nThe checksum is the sum of all of the bytes in the packet mod 256. Reads the next byte and compares it to the computed checksum.\nIf the checksum differs, sends a NAK byte and retries reception for the same packet. If the checksum is the same, sends an ACK byte and receives the next packet. To cancel a transfer, a CAN byte is sent by either the receiver or sender. When either side receives a CAN byte, it errors out, aborting the connection.\nTo end the transmission, the sender:\nSends an EOT byte. Waits for a NAK byte. If a different byte is received, the sender errors out. Sends a second EOT byte. Waits for an ACK byte. If a different byte is received, the sender errors out. To end the transmission, the receiver performs the following after receiving the first EOT:\nSends a NAK byte. Waits for a second EOT byte. If a different byte is received, the receiver cancels the transfer. Sends an ACK byte. Implementing XMODEM We have provided an unfinished implementation of the XMODEM protocol in the xmodem skeleton subdirectory. Your task is to complete the implementation by writing the expect_byte, expect_byte_or_cancel, read_packet, and write_packet methods in src/lib.rs. Your implementations should make use of the internal state of the Xmodem type: packet and started. We recommend reading over the existing code before starting.\nYou should begin by implementing the expect_byte and expect_byte_or_cancel methods. You should then make use of all four of the helper methods (including read_byte and write_byte) to implement read_packet and write_packet. To see how these methods are used, read the transmit and receive implementations which transmit or receive a complete data stream using XMODEM via these methods. Be mindful of the specifications in the doc-comments. You can test your implementation using cargo test. Once you are confident that your implementation is correct, proceed to the next subphase.\nDo not use any additional items from std.\nYour implementation should only use items from shim::io. It should not use other items from std or any other libraries.\nOur reference implementations for {read,write}_packet are roughly 43 lines of code each.\nThe io::Read and io::Write rustdocs will be useful.\nUse the ? operator generously.\nThe test source code can be a helpful guide.\nYou can use ioerr! macro to make and return a new io::Error easily. Please refer shim/src/macros.rs to find more macros which can be useful.\nSubphase D: ttywrite In this subphase, you will write a command line utility, ttywrite, that will allow you to send data to your Raspberry Pi in the raw or via the XMODEM protocol. You will use your xmodem library from the previous subphase in your implementation. You will write your code in ttywrite/src/main.rs. To test your ttywrite implementation, use the provided test.sh script.\nWhat is a serial device?\nA serial device is any device that accepts communication one bit at a time. This is known as serial communication. In contrast, in parallel communication multiple bits are being transferred at any point in time in parallel. We will be communicating with our Raspberry Pi via its UART device, a serial communication device.\nWhat is a TTY?\nA TTY is a \u0026ldquo;teletypewriter\u0026rdquo;. It is a vestigial term that was adopted in computing to describe computer terminals. The term later become more general, coming to describe any device intended to be communicated with over serial. For this reason, your computer calls the device mapping to your Raspberry Pi a TTY.\nCommand-Line Interface The skeleton code we have provided for ttywrite already parses and validates command-line arguments. To do so, it uses the structopt crate from crates.io which itself uses clap . You\u0026rsquo;ll notice that we list it as a dependency in the Cargo.toml file. structopt works through code generation. We simply annotate a structure and its fields with a declaration of our command-line arguments and structopt generates the code to actually parse the command-line flags.\nTo see the interface that structopt generates, call the application with --help. Remember that you can pass arbitrary flags when using cargo run: cargo run -- --help. Take a look at the interface now. Then, take a look at the Opt structure in main.rs and compare the interface with its definition.\nWhat happens when a flag\u0026rsquo;s input is invalid? (invalid)\nTry passing in some invalid values for flags. For instance, it should not be possible to set -f to idk. How does structopt know to reject invalid values?\nYou\u0026rsquo;ll notice that there are plenty of options. All of these correspond to settings available on a serial device. For now it\u0026rsquo;s not important to know exactly what these settings do.\nTalking to a Serial Device In main, you\u0026rsquo;ll see a call to serial::open . This is calling the open function from the serial crate, also on crates.io . This open function returns a TTYPort which allows you to read and write to the serial device (via its io::Read and io::Write trait implementations) as well as read and set settings on a serial device (via its SerialDevice trait implementation).\nWriting the Code Implement the ttywrite utility. Your implementation should set all of the appropriate settings passed in via the command-line stored in the opt variable in main. It should read from stdin if no input file is passed in or from the input file if one is passed in. It should write the input data to the passed in serial device. If the -r flag is set, it should send the data as it is. Otherwise, you should use your xmodem implementation from the previous subphase to send the data using the XMODEM protocol. You should print the number of bytes sent on a successful transmission.\nTo transmit using the XMODEM protocol, your code should use either the Xmodem::transmit or Xmodem::transmit_with_progress methods from the xmodem library. We recommend using transmit_with_progress so that your utility indicates progress throughput the transmission. In its simplest form, this might look as follows:\nfn progress_fn(progress: Progress) { println!(\u0026#34;Progress: {:?}\u0026#34;, progress); } Xmodem::transmit_with_progress(data, to, progress_fn) You can test the baseline correctness of your implementation using the test.sh script in the ttywrite directory. When your implementation is at least somewhat correct, you will see the following when the script is run:\nOpening PTYs... Running test 1/10. wrote 333 bytes to input ... Running test 10/10. wrote 232 bytes to input SUCCESS You can retrieve a handle to stdin with io::stdin() .\nYou may find the io::copy() function useful.\nThe main() function in our reference implementation is roughly 35 lines of code.\nKeep the TTYPort documentation open while writing your code.\nWhy does the test.sh script always set -r? (bad-tests)\nThe test.sh script that we have provided always uses the -r flag; it doesn\u0026rsquo;t test that your utility uses the XMODEM protocol when it is asked to. Why might that be? What does the XMODEM protocol expect that sending data in the raw doesn\u0026rsquo;t that makes testing its functionality difficult?\nInstalling ttywrite utility After finish writing the ttywrite utility, install the tool with cargo install --path . command. This command will be used later to communicate with the bootloader.\nPhase 2: Not a Seashell In this phase, you will be implementing drivers for the built-in timer, GPIO, and UART devices. You\u0026rsquo;ll use then these drivers to implement a simple shell. In the next phase, you\u0026rsquo;ll use the same drivers to implement a bootloader.\nWhat\u0026rsquo;s a driver?\nThe term driver, or device driver, describes software that directly interacts with and controls a hardware device. Drivers expose a higher-level interface to the hardware they control. Operating systems may interact with device drivers to expose an even higher-level interface. For instance, the Linux kernel exposes ALSA (Advanced Linux Sound Architecture), an audio API, which interacts with device drivers that in-turn interact directly with sound cards.\nSubphase A: Getting Started Project Structure Let\u0026rsquo;s recall the repository structure we saw at the beginning of this lab.\n. ├── ... ├── boot : bootloader * ├── kern : the main os kernel * └── lib : required libraries ├── pi * ├── shim ├── stack-vec * ├── ttywrite * ├── volatile * └── xmodem * All the libraries used by boot and kernel are located under the lib directory.\nshim library selectively depends on either std or no_std library. With #[cfg(feature = \u0026quot;no_std\u0026quot;)] specified, shim makes use of core_io and the custom no_std module which has minimum library we need such as ffi, path and sync. Otherwise, mostly in the test code, shim just uses std library.\npi subdirectory contains all of your driver code. The pi library makes use of the volatile library. It also depends on the shim library.\nboot and kernel make use of the pi library to communicate with hardware. They also depend on shim. In addition to that, boot also depends on the xmodem library, and kernel depends on the stack-vec library. The volatile library has no dependencies. The diagram below illustrates these relationships:\nKernel The kern directory contains the code for the operating system kernel: the core of your operating system. Calling make inside this directory builds the kernel. The build output is stored in the build/ directory. To run the kernel, copy the build/kernel.bin file to the root of the MicroSD card as kernel8.img. You may wish to use a script to copy the kernel image to the sdcard with make install command. Please refer the Tools page to find details about our Makefile.\nAt present, the kernel does absolutely nothing. By the end of this phase, the kernel will start up a shell which you can communicate with.\nAs we saw above, the kernel crate depends on the pi library. As a result, you can use all of the types and items from the pi library in the kernel.\nDocumentation While writing your device drivers, you\u0026rsquo;ll want to keep the BCM2837 ARM Peripherals Manual open.\nSubphase B: System Timer In this subphase, you will write a device driver for the ARM system timer. You will primarily be working in lib/pi/src/timer.rs and kern/src/main.rs. The ARM system timer is documented on page 172 (section 12) of the BCM2837 ARM Peripherals Manual .\nStart by looking at the existing code in lib/pi/src/timer.rs. In particular, note the relationship between the following sections:\nconst TIMER_REG_BASE: usize = IO_BASE + 0x3000; #[repr(C)] struct Registers { CS: Volatile\u0026lt;u32\u0026gt;, CLO: ReadVolatile\u0026lt;u32\u0026gt;, CHI: ReadVolatile\u0026lt;u32\u0026gt;, COMPARE: [Volatile\u0026lt;u32\u0026gt;; 4] } pub struct Timer { registers: \u0026amp;\u0026#39;static mut Registers } impl Timer { pub fn new() -\u0026gt; Timer { Timer { registers: unsafe { \u0026amp;mut *(TIMER_REG_BASE as *mut Registers) }, } } } The one line of unsafe in this program is very important: it casts the TIMER_REG_BASE address to a *mut Registers and then casts that to an \u0026amp;'static mut Registers. We are telling Rust that we have a static reference to a Registers structure at address TIMER_REG_BASE.\nWhat is at the TIMER_REG_BASE address? On page 172 of the BCM2837 ARM Peripherals Manual , you\u0026rsquo;ll find that 0x3000 is the peripheral offset for the ARM system timer. Thus, TIMER_REG_BASE is the address at which the ARM system timer registers start! After this one line of unsafe, we can use the registers field to access the timer\u0026rsquo;s registers safely. We can read the CLO register with self.registers.CLO.read() and write the CS register with self.registers.CS.write(), then combine them together to represent the number of elapsed microseconds.\nWhy can\u0026rsquo;t you write to CLO or CHI? (restricted-reads)\nThe BCM2837 documentation states that the CLO and CHI registers are read-only. Our code enforces this property. How? What prevents us from writing to CLO or CHI?\nWhat exactly is unsafe?\nIn short, unsafe is a marker for the Rust compiler that you\u0026rsquo;re taking control of memory safety: the compiler won\u0026rsquo;t protect you from memory issues. As a result, in unsafe sections, Rust lets you do anything you can do in C. In particular, you can cast between types with more freedom, dereference raw pointers, and fabricate lifetimes.\nBut note that unsafe is very unsafe. You must ensure that everything you do in an unsafe section is, in fact safe. This is more difficult than it sounds, especially when Rust\u0026rsquo;s idea of safe is much stricter than in other languages. As such, you should try not to use unsafe at all. For operating systems, unfortunately, we must use unsafe so that we can directly speak to hardware, but we\u0026rsquo;ll typically limit our use to one line per driver.\nIf you want to learn more about unsafe, read Chapter 1 of the Nomicon .\nImplement the Driver Implement the Timer::read(), current_time(), and spin_sleep() in lib/pi/src/timer.rs. The signatures on these items indicate their expected functionality. You\u0026rsquo;ll need to read the timer\u0026rsquo;s documentation in the BCM manual to implement Timer::read(). In particular, you should understand which registers to read to obtain the timer\u0026rsquo;s current u64 value. You can build the pi library with cargo build. You can also use cargo check to type-check the library without actually compiling it.\nYou\u0026rsquo;ll find the core::time::Duration page useful.\nTesting Your Driver Let\u0026rsquo;s test your driver by ensuring that spin_sleep() is accurate. We\u0026rsquo;ll write the code to do this in kern/src/main.rs.\nCopy your LED blinky code from phase 4 of lab 1 into main.rs. Instead of the for loop based sleep function, use your newly written spin_sleep() function with Duration to pause between blinks. Compile the kernel, load it onto the MicroSD card as kernel8.img, and then run it on the Raspberry Pi. Ensure that the LED blinks at the frequency that you intended it to. Try other pause times and ensure that they all work as expected. Until you write the bootloader in phase 3, you\u0026rsquo;ll need to keep swapping the MicroSD card between the Pi and your computer to try out different binaries.\nIf your timer driver is working as expected, proceed to the next subphase.\nSubphase C: GPIO In this subphase, you will write a generic, pin-independent device driver for GPIO. You will primarily be working in lib/pi/src/gpio.rs and kern/src/main.rs. The GPIO subsystem is documented on page 89 (section 6) of the BCM2837 ARM Peripherals Manual .\nState Machines All hardware devices are state machines : they begin at a predetermined state and transition to different states based on explicit or implicit inputs. The device exposes different functionality depending on which state it is in. In other words, only some transitions are valid in some states. Importantly, this implies that some transitions are invalid when the device is in a given state.\nMost programming languages make it impossible to faithfully encode the semantics of a state machine in hardware, but not Rust! Rust lets us perfectly encode state machine semantics, and we\u0026rsquo;ll take advantage of this to implement a safer-than-safe device driver for the GPIO subsystem. Our driver will ensure that a GPIO pin is never misused, and it will do so at compile-time.\nBelow is the state diagram for a subset of the GPIO state machine for a single pin:\nGPIO State Diagram Our goal is to encode this state machine in Rust. Let\u0026rsquo;s start by interpreting the diagram:\nThe GPIO starts in the START state.\nFrom the START state it can transition to one of three states:\nALT - no transitions are possible from this state OUTPUT - two \u0026ldquo;self\u0026rdquo; transitions are possible: SET and CLEAR INPUT - one \u0026ldquo;self\u0026rdquo; transition is possible: LEVEL Which transitions did you follow in your lab 1 blinky? (blinky-states)\nWhen you implementing the blinky code in phase 4 of lab 1, you implicitly implemented a subset of this state machine. Which transitions did your code implement?\nWe\u0026rsquo;ll use Rust\u0026rsquo;s type system to ensure that a pin can only be SET and CLEARed if it has been transitioned to the OUTPUT state and the LEVEL read if it is in the INPUT state. Take a look at the declaration for the GPIO structure in lib/pi/src/gpio.rs:\npub struct Gpio\u0026lt;State\u0026gt; { pin: u8, registers: \u0026amp;\u0026#39;static mut Registers, _state: PhantomData\u0026lt;State\u0026gt; } The structure has one generic argument, State. Except for PhantomData, nothing actually uses this argument. This is what PhantomData is there for: to convince Rust that the structure somehow uses the generic even though it otherwise wouldn\u0026rsquo;t. We\u0026rsquo;re going to use the State generic to encode which state the Gpio device is in. Unlike other generics, we must control this parameter and ensure that a client can never fabricate it.\nThe state! macro generates types that represent the states a Gpio can be in:\nstates! { Uninitialized, Input, Output, Alt } // Each parameter expands to an `enum` that looks like: enum Input { } This is also weird; why would we create an enum with no variants? enum\u0026rsquo;s with no variants have a nice property: they can never be instantiated. In this way, these types act purely as markers. No one can ever pass us a value of type Input because such a value can never be constructed. They exist purely at the type-level.\nWe can then implement methods corresponding to valid transitions given that a Gpio is in a certain state:\nimpl Gpio\u0026lt;Output\u0026gt; { /// Sets (turns on) the pin. pub fn set(\u0026amp;mut self) { ... } /// Clears (turns off) the pin. pub fn clear(\u0026amp;mut self) { ... } } impl Gpio\u0026lt;Input\u0026gt; { /// Reads the pin\u0026#39;s value. pub fn level(\u0026amp;mut self) -\u0026gt; bool { ... } } This ensures that a Gpio can only be set and cleared when it is a Gpio\u0026lt;Output\u0026gt; and its level read when it is a Gpio\u0026lt;Input\u0026gt;. Perfect! But how do we actually transition between states? Hello, Gpio::transition()!\nimpl\u0026lt;T\u0026gt; Gpio\u0026lt;T\u0026gt; { fn transition\u0026lt;S\u0026gt;(self) -\u0026gt; Gpio\u0026lt;S\u0026gt; { Gpio { pin: self.pin, registers: self.registers, _state: PhantomData } } } This method lets us transition a Gpio from any state to any other state. Given a Gpio in state T, this method returns a Gpio in state S. Note that it works for all S and T. We must be very careful when calling this method. When called, we are encoding the specification of a transition in the state diagram. If we get the specification or encoding wrong, our driver is wrong.\nTo use the transition() method, we need to tell Rust which type we want as an output S in Gpio\u0026lt;S\u0026gt;. We do this by giving Rust enough information so that it can infer the S type. For instance, consider the implementation of the into_output method:\npub fn into_output(self) -\u0026gt; Gpio\u0026lt;Output\u0026gt; { self.into_alt(Function::Output).transition() } This method requires its return type to be Gpio\u0026lt;Output\u0026gt;. When the Rust type system inspects the call to transition(), it will search for a Gpio::transition() method that returns a Gpio\u0026lt;Output\u0026gt; to satisfy the requirement. Since our transition method returns Gpio\u0026lt;S\u0026gt; for any S, Rust will replace S with Output and use that method. The result is that we\u0026rsquo;ve transformed our Gpio\u0026lt;Alt\u0026gt; (from the into_alt() call) into a Gpio\u0026lt;Output\u0026gt;.\nWhat would go wrong if a client fabricates states? (fake-states)\nConsider what would happen if we let the user choose the initial state for a Gpio structure. What could go wrong?\nWhy is this only possible with Rust?\nNotice that the into_ transition methods take a Gpio by move. This means that once a Gpio is transitioned into a another state, it can never be accessed in the previous state. Rust\u0026rsquo;s move semantics make this possible. As long as a type doesn\u0026rsquo;t implement Clone, Copy, or some other means of duplication, there is no coming back from a transition. No other language, not even C++, affords us this guarantee at compile-time.\nImplement the Driver Implement the unimplemented!() methods in lib/pi/src/gpio.rs. The signatures on these items indicate their expected functionality. You\u0026rsquo;ll need to read the GPIO documentation (page 89, section 6 of the BCM2837 ARM Peripherals Manual ) to implement your driver. Remember that you can use cargo check to type-check the library without actually compiling it.\nTesting Your Driver We\u0026rsquo;ll again write code in kern/src/main.rs to ensure that our driver works as expected.\nInstead of reading/writing to raw memory addresses, use your new GPIO driver to set and clear GPIO pin 16. Your code should get a lot cleaner. Compile the kernel, load it onto the MicroSD card as kernel8.img, run it on the Raspberry Pi, and ensure your LED blinks as before.\nNow, connect more LEDs to your Raspberry Pi. Use GPIO pins 5, 6, 13, 19, and 26. Refer to the pin numbering diagram from assignment 0 to determine their physical location. Have your kernel blink all of the LEDs in a pattern of your choice.\nWhich pattern did you choose? (led-pattern)\nWhat pattern did you have your LEDs blink in? If you haven\u0026rsquo;t yet decided, one fun idea is to have them imitate a \u0026ldquo;loading spinner\u0026rdquo; by arranging the LEDs in a circle and turning them on/off in a sequential, circular pattern. Once your GPIO driver is working as expected, proceed to the next subphase.\nSubphase D: UART In this subphase, you will write a device driver for the mini UART device on the Raspberry Pi. You will primarily be working in lib/pi/src/uart.rs and kern/src/main.rs. The mini UART is documented on page 8 and page 10 (sections 2.1 and 2.2) of the BCM2837 ARM Peripherals Manual .\nUART: Universal Asynchronous RX/TX A UART , or universal asynchronous receiver-transmitter, is a device and serial protocol for communicating over two wires. These are the two wires (rx/tx) that you used in phase 1 of lab 0 to connect the UART device on the CP2102 USB module to the UART device on the Pi. You can send any kind of data over UART: text, binaries, images, anything! As an example, in the next subphase, you\u0026rsquo;ll implement a shell by reading from the UART device on the Pi and writing to the UART device on the CP2102 USB module. In phase 3, you\u0026rsquo;ll read from the UART on the Pi to download a binary being sent via the UART on the CP2102 USB module.\nThe UART protocol has several configuration parameters, and both the receiver and transmitter need to be configured identically to communicate. These parameters are:\nData Size: length of a single data frame (8 or 9 bits) Parity Bit: whether to send a parity (checksum) bit after the data Stop Bits: how many bits to use to signal the end of the data (1 or 2) Baud Rate: transmission rate in bits/second The mini UART on the Pi does not support parity bits and only supports 1 stop bit. As such, only the baud rate and data frame length need to be configured. To learn more about UART, see the Basics of UART Communication article.\nImplement the Driver At this point, you have all of the tools to write a device driver without additional background information (congratulations! ðŸŽ‰).\nImplement the mini UART device driver in lib/pi/src/uart.rs. You\u0026rsquo;ll need to complete the definition of the Registers structure. Ensure that you use the Volatile type with the minimal set of capabilities for each register: read-only registers should use ReadVolatile, write-only registers should use WriteVolatile, and reserved space should use Reserved. Then, initialize the device in new() by setting the baud rate to 115200 (a divider of 270) and data length to 8 bits. Finally, implement the remaining unimplemented!() methods and the fmt::Write, io::Read and io::Write traits for MiniUart.\nYou\u0026rsquo;ll need to write to the LCR, BAUD, and CNTL registers in new.\nUse your GPIO driver from the previous subphase.\nTesting Your Driver Test your driver by writing a simple \u0026ldquo;echo\u0026rdquo; program in kern/src/main.rs: sit in a hot loop writing out every byte you read in. In pseudocode, this looks like:\nloop { write_byte(read_byte()) } Use screen /dev/\u0026lt;your-path\u0026gt; 115200 to communicate over UART. screen sends every keypress over the TTY, so if your echo program works correctly, you\u0026rsquo;ll see every character you type. It might help to send an extra character or two each time you receive a byte to convince yourself things are working as you expect:\nloop { write_byte(read_byte()) write_str(\u0026#34;\u0026lt;-\u0026#34;) } Once your driver works as expected, proceed to the next subphase.\nSubphase E: The Shell In this subphase, you\u0026rsquo;ll use your new UART driver to implement a simple shell that will be the interface to your operating system. You will be working in kern/src/console.rs, kern/src/shell.rs, and kernel/src/main.rs.\nThe Console To write our shell, we\u0026rsquo;ll need some notion of a global default input and output. Unix and friends typically refer to this is as stdin and stdout; we\u0026rsquo;ll be calling it Console. Console will allow us to implement the kprint! and kprintln! macros, our kernel-space versions of the familiar print! and println!, and give us a default source for reading user input. We\u0026rsquo;ll use Console and these macros to implement our shell.\nTake a peek at kernel/src/console.rs. The file contains an unfinished implementation of the Console struct. Console is a singleton wrapper around a MiniUart: only one instance of Console will ever exist in our kernel. That instance will be globally available, for use anywhere and by anything. This will allow us to read and write to the mini UART without explicitly passing around an instance of MiniUart or Console.\nGlobal Mutability The notion of a globally mutable structure is a scary thought, especially in the face of Rust. After all, Rust doesn\u0026rsquo;t allow more than one mutable reference to a value, so how can we possibly convince it to allow as many as we want? The trick, of course, relies on unsafe. The idea is as follows: we\u0026rsquo;ll tell Rust that we\u0026rsquo;re only going to read a value by using an immutable reference, but what we actually do is use unsafe to \u0026ldquo;cast\u0026rdquo; that immutable reference to a mutable reference. Because we can create as many immutable references as we want, Rust will be none the wiser, and we\u0026rsquo;ll have all of the mutable references we desire!\nSuch a function might look like this:\n// This function must never exist. fn make_mut\u0026lt;T\u0026gt;(value: \u0026amp;T) -\u0026gt; \u0026amp;mut T { unsafe { /* magic */ } } Your alarm bells should be ringing: what we\u0026rsquo;ve proposed so far is wildly unsafe. Recall that we still need to ensure that everything we do in unsafe upholds Rust\u0026rsquo;s rules. What we\u0026rsquo;ve proposed thus far clearly does not. As it stands, we\u0026rsquo;re violating the \u0026ldquo;at most one mutable reference at a time\u0026rdquo; rule. The rule states that at any point in the program, a value should have at most one mutable reference to it.\nThe key insight to maintaining this rule while meeting our requirements is as follows: instead of the compiler checking the rule for us with its borrow and ownership checker, we will ensure that the rule is upheld dynamically, at run-time. As a result, we\u0026rsquo;ll be able to share references to a structure as many times as we want (via an \u0026amp; reference) while also being able to safely retrieve a mutable reference when we need it (via our \u0026amp;T -\u0026gt; \u0026amp;mut T dynamic borrow checking function).\nThere are many concrete implementations of this idea. One such implementation ensures that only one mutable reference is returned at a time using a lock:\nfn lock\u0026lt;T\u0026gt;(value: \u0026amp;T) -\u0026gt; Locked\u0026lt;\u0026amp;mut T\u0026gt; { unsafe { lock(value); cast value to Locked\u0026lt;\u0026amp;mut T\u0026gt; } } impl Drop for Locked\u0026lt;\u0026amp;mut T\u0026gt; { fn drop(\u0026amp;mut self) { unlock(self.value) } } This is known as Mutex in the standard library. Another way is to abort the program if more than one mutable reference is about to be created:\nfn get_mut\u0026lt;T\u0026gt;(value: \u0026amp;T) -\u0026gt; Mut\u0026lt;\u0026amp;mut T\u0026gt; { unsafe { if ref_count(value) != 0 { panic!() } ref_count(value) += 1; cast value to Mut\u0026lt;\u0026amp;mut T\u0026gt; } } impl Drop for Mut\u0026lt;\u0026amp;mut T\u0026gt; { fn drop(\u0026amp;mut self) { ref_count(value) -= 1; } } This is RefCell::borrow_mut() . And yet another is to only return a mutable reference if it is known to be exclusive:\nfn get_mut\u0026lt;T\u0026gt;(value: \u0026amp;T) -\u0026gt; Option\u0026lt;Mut\u0026lt;\u0026amp;mut T\u0026gt;\u0026gt; { unsafe { if ref_count(value) != 0 { None } else { ref_count(value) += 1; Some(cast value to Mut\u0026lt;\u0026amp;mut T\u0026gt;) } } } impl Drop for Mut\u0026lt;\u0026amp;mut T\u0026gt; { fn drop(\u0026amp;mut self) { ref_count(value) -= 1; } } This is RefCell::try_borrow_mut() . All of these examples implement some form of \u0026ldquo;interior mutability\u0026rdquo;: they allow a value to be mutated through an immutable reference. For our Console, we\u0026rsquo;ll be using Mutex to accomplish the same goal. Since the std::Mutex implementation requires operating system support, we\u0026rsquo;ve implemented our own Mutex in kern/src/mutex.rs. Our implementation is correct for now, but we\u0026rsquo;ll need to fix it when we introduce caching or concurrency to continue to uphold Rust\u0026rsquo;s rules. You don\u0026rsquo;t need to understand the Mutex implementation for now, but you should understand how to use one.\nThe global singleton is declared as CONSOLE in kern/src/console.rs. The global variable is used by the kprint! and kprintln! macros defined below below. Once you\u0026rsquo;ve implemented Console, you\u0026rsquo;ll be able to use kprint! and kprintln! to print to the console. You\u0026rsquo;ll also be able to use CONSOLE to globally access the console.\nRust also requires static globals to be Sync.\nIn order to store a value of type T in a static global, T must implement Sync. This is because Rust also guarantees data race safety at compile-time. Because global values can be accessed from any thread, Rust must ensure that those accesses are thread-safe. The Send and Sync traits, along with Rust\u0026rsquo;s ownership system, ensure data race freedom.\nWhy should we never return an \u0026amp;mut T directly? (drop-container)\nYou\u0026rsquo;ll notice that every example we\u0026rsquo;ve provided wraps the mutable reference in a container and then implements Drop for that container. What would go wrong if we returned an \u0026amp;mut T directly instead?\nWhere does the write_fmt call go? (write-fmt)\nThe _print helper function calls write_fmt on an instance of MutexGuard\u0026lt;Console\u0026gt;, the return value from Mutex\u0026lt;Console\u0026gt;::lock(). Which type will have its write_fmt method called, and where does the method implementation come from?\nImplement and Test Console implement all of the unimplemented!() methods in kern/src/console.rs. once you\u0026rsquo;ve implemented everything, use the kprint! and kprintln! macros in kern/src/main.rs to write to the console when you receive a character. you can use these macros exactly like print! and println!. use screen /dev/\u0026lt;your-path\u0026gt; 115200 to communicate with your pi and ensure that your kernel works as expected.\nIf this were C\u0026hellip;\nThe fact that we get a println! implementation for free with zero effort is just another advantage to using Rust. If this were C, we\u0026rsquo;d need to implement printf ourselves. In Rust, the compiler provides a generic, abstracted, and safe OS-independent implementation. Whew!\nYour Console implementations should be very short: about a line each.\nImplement the Shell Finished Product You\u0026rsquo;re now ready to implement the shell in kern/src/shell.rs. We\u0026rsquo;ve provided a Command structure for your use. The Command::parse() method provides a simple command-line argument parser, returning a Command struct. The parse method splits the passed in string on spaces and stores all of the non-empty arguments in the args field as a StackVec using the passed in buf as storage. You must implement Command::path() yourself.\nUse all of your available libraries (Command, StackVec, Console via CONSOLE, kprint!, kprintln!, and anything else!) to implement a shell in the shell function. Your shell should print the prefix string on each line it waits for input. In the GIF above, for instance, \u0026quot;\u0026gt; \u0026quot; is being used as the prefix. Your shell should then read a line of input from the user, parse the line into a command, and attempt to execute it. It should do this ad-infinitum. Since our operating system is only just beginning, we can\u0026rsquo;t run any interesting commands just yet. We can, however, build known commands like echo into the shell.\nTo complete your implementation, your shell should\u0026hellip;\nimplement the echo built-in: echo $a $b $c should print $a $b $c accept both \\r and \\n as \u0026ldquo;enter\u0026rdquo;, marking the end of a line accept both backspace and delete (ASCII 8 and 127) to erase a single character ring the bell (ASCII 7) if an unrecognized non-visible character is sent to it print unknown command: $command for an unknown command $command disallow backspacing through the prefix disallow typing more characters than allowed accept commands at most 512 bytes in length accept at most 64 arguments per command start a new line, without error, with the prefix if the user enters an empty command print error: too many arguments if the user passes in too many arguments Test your implementation by calling your new shell() function in kern/src/main.rs. Minus the \u0026ldquo;SOS\u0026rdquo; banner, you should be able to replicate the GIF above. You should also be able to test all of the requirements we\u0026rsquo;ve set. Once your shell works as expected, revel in your accomplishments. Then, proceed to the next phase.\nA byte literal, b'a' is the u8 ASCII value for a character 'a'.\nUse \\u{b} in a string literal to print any character with ASCII byte value b.\nYou must print both \\r and \\n to begin a new line at the line start.\nTo erase a character, backspace, print a space, then backspace again.\nUse StackVec to buffer the user\u0026rsquo;s input.\nYou\u0026rsquo;ll find the core::str::from_utf8() function useful.\nHow does your shell tie the many pieces together? (shell-lookback)\nYour shell makes use of much of the code you\u0026rsquo;ve written. Briefly explain: which pieces does it makes use of and in what way?\nPhase 3: Boot \u0026rsquo;em Up In this phase, you\u0026rsquo;ll use everything you\u0026rsquo;ve written thus far to implement a bootloader for your Raspberry Pi. You\u0026rsquo;ll be working primarily in boot/src/main.rs.\nYou\u0026rsquo;ve likely become frustrated with the monotonous motions of swapping MicroSD cards to load a new binary onto your Pi. The bootloader you will write in this phase eliminates that process entirely. You\u0026rsquo;ll replace the binary on the MicroSD one more time, this time with the bootloader. From then on, you can load new binaries remotely from your computer without ever touching the MicroSD card again.\nThe bootloader itself is a \u0026ldquo;kernel\u0026rdquo; of sorts that accepts XMODEM file transfers over UART. It writes the data received into memory at a known address and then executes it. We\u0026rsquo;ll use our ttywrite utility to send it binaries. As a result, the process to load a new binary onto the Pi will be as simple as:\n#. Resetting the Pi to start the bootloader. #. Run make transmit command, which will build your kernel and transmit it with ttywrite -i build/kern.bin /dev/ttyUSB0 command.\nLoading Binaries By default, the Raspberry Pi 3 loads files named kernel8.img at address 0x80000. Said another way, the Pi will sequentially copy the contents of kernel8.img to 0x80000 and, after some initialization, set the ARM\u0026rsquo;s program counter to 0x80000. As a result, we must ensure that our binary expects to be loaded at this address. This means that all of the addresses in the binary should begin at 0x80000.\nBecause the linker is what decides the addresses for all symbols in our binary, we must somehow inform the linker of this desire. To do this, we use a linker script: a file read by the linker that describes how we want it to assign addresses to symbols in our binary. Our kernel\u0026rsquo;s linker script can be found in kern/.cargo/layout.ld. You\u0026rsquo;ll notice the address 0x80000 on the second line. Indeed, this line instructs the linker to begin allocating addresses at 0x80000.\nTo maintain compatibility with these defaults, our bootloader will also load binaries at address 0x80000. But this raises an issue: if our bootloader\u0026rsquo;s binary is at address 0x80000, loading a different binary at the same address will result in overwriting our bootloader as we\u0026rsquo;re executing it! To avoid this conflict, we must use different start addresses for the bootloader and the binaries it loads. We\u0026rsquo;d like to maintain compatibility with the Pi\u0026rsquo;s defaults, so we\u0026rsquo;ll need to change the start address of the bootloader. How?\nMaking Space The first step is to choose a new address. As you can see in boot/.cargo/layout.ld, we\u0026rsquo;ve chosen 0x4000000 as the start address for our bootloader. While this fixes the addresses in the binary, the Pi will continue to load it at 0x80000. Thankfully, we can ask the Pi to load our binary at a different address via a kernel_address parameter in the firmware\u0026rsquo;s config.txt. Ensure you modify your config.txt in microSD to have kernel_address=0x4000000 line.\nAs a result of this change, the memory between 0x80000 and 0x4000000 will be entirely unused by the bootloader, and we can load binaries up to 0x4000000 - 0x80000 bytes in size without conflict.\nIs 63.5MiB really enough? (small-kernels)\nYou might be thinking that the free space we\u0026rsquo;ve set apart isn\u0026rsquo;t enough. This is a fair concern. One way to answer the question is to look at the file size of kernels from successful operating systems. Would they fit?\nDetermine how large the kernel binary is for the operating system you\u0026rsquo;re running now. On newer versions of macOS, the binary is /System/Library/Kernels/kernel. On older versions of macOS, the binary is /mach_kernel. On Linux, the binary is usually located in /boot/ and is named either vmlinuz, vmlinux, or bzImage. How big is your kernel\u0026rsquo;s binary? Would it fit in the 63.5MiB free space we\u0026rsquo;ve created?\nImplement the Bootloader Implement the bootloader in boot/src/main.rs. We\u0026rsquo;ve declared the bootloader\u0026rsquo;s start address, the loaded binary\u0026rsquo;s start address, and the maximum binary size in const declarations at the top of the file. We\u0026rsquo;ve also provided a jump_to function that unconditionally branches to the address addr. This has the effect of setting the program counter to that address. Your bootloader should use these declarations along with your existing code from the pi and xmodem libraries to receive a transmission over UART and write it to the memory address the binary expects to be loaded at. When the transmission is complete, your bootloader should execute the new binary.\nBe aware that your bootloader should continuously attempt to initiate an XMODEM reception by setting a low timeout value (say, 750ms) and attempting a new reception if a timeout occurs. If a reception fails for any other reason, print an error message and try again. Once you\u0026rsquo;ve implemented the bootloader, test it by sending your kernel binary from kern/build/kernel.bin to your Pi using your ttywrite utility. If all is well, you should see your shell when you screen into your Pi.\nWhy is the timeout necessary? (bootloader-timeout)\nWithout the bootloader timing out and retrying a reception, it is possible for the transmitter to stall indefinitely under some conditions. What are those conditions, and why would the transmitter stall indefinitely?\nconfig.txt\nRemember to use the version of config.txt compatible with bootloader binaries!\nOur reference main() function is 15 lines of code.\nYou\u0026rsquo;ll find the core::slice::from_raw_parts_mut() function useful.\nThe \u0026amp;mut [u8] type implements io::Write.\nSubmission Once you\u0026rsquo;ve completed the tasks above, you\u0026rsquo;re done and ready to submit! Congratulations!\nEnsure you\u0026rsquo;ve committed your changes. Any uncommitted changes will not be visible to us, thus unconsidered for grading.\nBefore submitting, check if you\u0026rsquo;ve answered every question and passed every unit tests for the libraries. Note that there are no unit tests for pi and kernel. You\u0026rsquo;re responsible for ensuring that they work as expected.\nWhen you\u0026rsquo;re ready, push a commit to your GitHub repository with a tag named lab2-done.\n# submit lab1 $ git tag lab2-done $ git push --tags ", 
        "url": "\/\/localhost:1313\/post\/lab2\/"
    },
    
    "\/\/localhost:1313\/tags\/": {
        "title": "Tags",
        "tags": [],
        "content": "", 
        "url": "\/\/localhost:1313\/tags\/"
    },
    
    "\/\/localhost:1313\/post\/lab1\/": {
        "title": "Lab 1: Bootstrapping Raspberry Pi",
        "tags": ["Lab",],
        "content": " Handed out: Tuesday, January 21, 2020 Due: Monday, January 27, 2020 Introduction In this assignment, you will set up and test a Raspberry Pi 3, ARM64 development environment for your use throughout the rest of the course. You\u0026rsquo;ll install the necessary tools and write your first bare-metal application, an LED blinky program, in two languages: C and Rust.\nThis assignment is divided into 4 phases. In the first phase, you\u0026rsquo;ll install the necessary software to communicate with your Pi from your machine. You\u0026rsquo;ll also ensure that your Pi works as expected by running a pre-compiled program. In the second phase, you\u0026rsquo;ll connect GPIO pin 16 on your Raspberry Pi to an LED and run a second pre-compiled program to ensure your connections are sound. In the third phase, you\u0026rsquo;ll write, cross-compile, and link a C program that toggles GPIO pin 16 on and off, blinking the LED connected to your Pi. Finally, in phase 4, you\u0026rsquo;ll write, cross-compile, and link the same program in Rust .\nPhase 0: Preflight Check First and foremost, check that your Raspberry Pi kit includes all of the following materials:\n1 x Raspberry Pi 3/B/B+ 1 x microSD card (4-32GB) 1 x microSD reader We will provide you these items in class:\n1 x CP2102 USB 4 x female-female jumper cables 5 x multicolored LEDs 5 x 100 ohm resistors 10 x female-male DuPont jumper cables Electronics are sensitive to electrostatic discharge, so ensure that you ground yourself by touching something conductive before touching any electronics. Prepare two male to female jumper cables for use as well as one resistor (any resistor!) and one LED. Finally, ready the USB microSD card adapter.\nGetting the Skeleton Code To get the skeleton code for lab1, you should fetch the updates from our git repository to your development machine.\n$ git fetch skeleton $ git merge skeleton/lab1 This is the directory structure of our repository.\n. ├── bin : common binaries/utilities ├── doc : reference documents ├── ext : external files (e.g., resources for testing) └── tut : tutorial/practices ├── 0-rustlings └── 1-blinky : this contains files for lab1 As your changes in the previous lab are in tut/0-rustlings, it\u0026rsquo;s unlikely that the merging process should be seamless. If not, please resolve the conflict and proceed to the next phase.\nFeel free to explore the contents of the repository.\nPhase 1: Baking Pi The primary means through which you\u0026rsquo;ll be powering and communicating with your Pi is via a CP2102 USB module. That\u0026rsquo;s the red USB dongle with the five pins.\nIf you are working on virtual machine, you need to configure some setting to enable USB port for microSD card adapter and CP2102. Please refer the Tools page if you haven\u0026rsquo;t set up yet.\nTo test if your CP2102 is working properly, plug it in to a USB port of the development machine with the yellow cap attached. The cap should connext TXD and RXD pins of the serial device. It simply wires both input and output pins of the serial, so you will receive what you send.\nTo see the data you receive from the module, you\u0026rsquo;ll need to run a serial console emulator that connects to the CP2102 module and reads the incoming data. We\u0026rsquo;ll use screen since it comes preinstalled on Linux. Recalling the /dev path for your CP2102 module (this will likely be /dev/ttyUSB0), connect to the CP2102 USB module with screen by running:\n$ screen /dev/\u0026lt;your-path\u0026gt; 115200 You may have to use sudo to run the command. Alternatively, you can add yourself to the dialout user group to avoid using sudo:\n$ sudo gpasswd --add \u0026lt;your-username\u0026gt; dialout If everything goes well, you will see what you type in the screen console as well as the small led lights on the USB module blinking whenever you type. If your CP2102 works as expected, it\u0026rsquo;s time to wire CP2102 to Raspberry Pi. To exit screen, use \u0026lt;ctrl-a\u0026gt; k then answer y at the prompt.\nPowering the Pi First, disconnect the CP2102 module from your computer. Now connect the Raspberry Pi to the CP2102 module using the four female-female jumper cables. The table below shows which pins on the CP2102 module you should connect to which pins on the Raspberry Pi. You can see the CP2102 module pins\u0026rsquo; names if you look at the back of the module\u0026rsquo;s board.\nCP2102 Pin Pi Physical Pin +5v 4 GND 6 RXD 8 TXD 10 Here\u0026rsquo;s how the pins are numbered on the Raspberry Pi 3:\nHere\u0026rsquo;s what the connections should look like (connections not ordered in this pic, just look at the name of the pins):\nDouble-check, triple-check, and quadruple-check your connections! Then, get a friend to double-check your connections! Incorrect wiring can result in a fried Raspberry Pi, which will result in an automatic F in this course. Okay, that last bit isn\u0026rsquo;t true, but Raspberry Pi 3\u0026rsquo;s are expensive, and we don\u0026rsquo;t want to pass out additional ones if we can prevent it. So, quintuple-check your connections before continuing!\nIf you\u0026rsquo;re confident in your connections, it\u0026rsquo;s time to plug in your CP2102 module into your computer. If all went well, you should see a red LED light on your Raspberry Pi shining bright. Congratulations! You\u0026rsquo;re now able to power and communicate with your Pi.\nRunning Programs As discussed in lecture, the Raspberry Pi loads programs on boot from the on-board microSD card. We\u0026rsquo;ll now set up our microSD card with a custom program for the Raspberry Pi to load.\nIn the repo, you can find a testing programs: ext/rpi3-gpio16. To load this program on the Pi, you can simply copy files in the directory to the microSD card - take the microSD card and insert it into the USB microSD card reader. Then, plug the adapter into your machine. You should see a new volume mounted on your machine. (If not, see tools page) Format the microSD card with FAT32 filesystem. Then copy the all files inside the directory (i.e., bootcode.bin, config.txt, fixup.dat, start.elf and kernel8.img), to the root of the microSD card. As discussed in lecture, these are four of the five files read by the GPU on boot. The fifth, kernel8.img, is the boot program, which we are about to install.\nWhat are bootcode.bin, config.txt, and start.elf?\nThese specially-named files are recognized by the Raspberry Pi\u0026rsquo;s GPU on boot-up and used to configure and boostrap the system. bootcode.bin is the GPU\u0026rsquo;s first-stage bootloader. Its primary job is to load start.elf, the GPU\u0026rsquo;s second-stage bootloader. start.elf initializes the ARM CPU, configuring it as indicated in config.txt, loads kernel8.img into memory, and instructs the CPU to start executing the newly loaded code from kernel8.img.\nNow, let\u0026rsquo;s ensure your pi and serial works as expected. Having copied all the five files inside ext/rpi3-gpio16 from the repo to the root of the microSD card,unmount the microSD card, disconnect the USB adapter from your machine, and remove the microSD card from the USB adapter. Ensure your Raspberry Pi 3 isn\u0026rsquo;t currently powered. Then, insert the microSD card into the Rasperry Pi 3. Plug in the Pi. In just a short moment, you should see a green LED on the Raspberry Pi board blinking very fast. You should also see a red LED on the USB CP2102 adapter blinking at the same frequency. This indicates that data is being sent to/from the Raspberry Pi.\nThis process is very tedious and error-prone. Feel free to use a script prepared (bin/install-kernel.py). You can simply specify a kernel or directory for installation, like bin/install-kernel.py ext/rpi3-gpio16. The script will prompt you for the directory where the microSD card was mounted, after you provide that, the script will copy all the files inside the directory you gave in the arguments to the microSD and unmount the microSD for you; so you can directly disconnect it from the computer.\nTo see the data the Raspberry Pi is sending, you\u0026rsquo;ll need to run a serial console emulator that connects to the CP2102 module and reads the incoming data, like described above.\nMake sure your Pi has enough power\nYour Pi will get its power from your computer, through the CP2102 module. Your computer may not supply enough power, which will cause your Pi to be under-powered. An under-powered Pi have indeterministic behavior, it may even corrupt your microSD card. Make sure that your Pi has enough power by checking the red led light on the corner of your Pi: it should be a steady ON when your Pi is connected.\nPhase 2: LED There Be Light In this phase, you\u0026rsquo;ll connect GPIO pin 16 (physical pin 36) on the Raspberry Pi to an LED light. You\u0026rsquo;ll test the LED using a pre-compiled binary. Before starting, ensure your Raspberry Pi is unplugged.\nIs it safe to simply unplug the USB TTL adapter?\nYes! On a traditional computer, and later on in the course, removing the power source without consideration is a bad idea because operations, typically on the disk, may be in-flight. Stopping these operations midway can result in damaged hardware or inconsistent state on the next boot-up. For now, our Pis have no state or moving hardware, so we don\u0026rsquo;t need to worry about this. Feel free to simply unplug its power source!\nGPIO: General Purpose I/O GPIO stands for General Purpose Input/Output. As the name implies, GPIO is a general mechanism for transmitting data/signals into and out of some device through electrical pins, known as GPIO pins.\nA GPIO pin can act as either an output or input. When a GPIO pin is acting as an output, it can either be set on or off. When on, the Raspberry Pi drives the pin at 3.3v. When the GPIO pin is off, no current flows through the pin. When a GPIO pin is acting as an input, the Raspberry Pi reports whether the pin is being driven at 3.3v or not.\nGPIO pins are incredibly versatile and can be used to implement a wide array of functionality. You can read more about GPIO on the Raspberry Pi Foundation\u0026rsquo;s GPIO Usage Documentation .\nTesting the LED We\u0026rsquo;ll start by constructing the circuit below:\nThis circuit connects an LED to always-on 3.3v power on the Raspberry Pi. Note that pin 1 (+3.3v) on the Raspberry Pi should go to the longer leg of your LED. The shorter leg is connected to the resistor which in-turn is connected to pin 14 (ground) on the Pi.\nAfter you\u0026rsquo;ve confirmed your connections, plug the Raspberry Pi in. Your LED should turn on. After you\u0026rsquo;ve confirmed that the LED works as expected, unplug your Rapsberry Pi. Then, move the jumper cable from pin 1 on the Pi to pin 36 (GPIO Pin 16) as illustrated below:\nHaving installed our ext/rpi3-gpio16 kernel in the microSD card, which drives GPIO pin 16 on and off repeatedly; once you plug your Pi in with the microSD inserted, you should see your LED start blinking.\nPhase 3: Shining C In this phase, you\u0026rsquo;ll write the program that produced ext/rpi3-gpio16/kernel8.img in C. You\u0026rsquo;ll write your code in tut/1-blinky/phase3/blinky.c. To be able to compile C and assembly programs for the Raspberry Pi, we\u0026rsquo;ll use a cross compiler for the aarch64-none-elf target that is in the bin directory on the repository.\nTalking to Hardware The vast majority of modern hardware devices communicate with software through memory-mapped I/O. The concept is simple: devices expose their functionality through the machine\u0026rsquo;s memory and provide a specification about what will happen if certain addresses are read or written to. Addresses are usually separated into 32 or 64-bit sized regions known as registers. Registers are usually named to indicate their functionality. Registers can be read-only, write-only, or read/write.\nHow do we know which registers a device exposes, where in memory they\u0026rsquo;re mapped, and what they do? Device manufacturers document all of this information in what is typically referred to as a \u0026ldquo;data sheet\u0026rdquo;, \u0026ldquo;device manual\u0026rdquo;, or simply \u0026ldquo;documentation\u0026rdquo;. There is no widespread format for how devices are documented, and documentation quality is hit or miss. Reading and understanding hardware documentation is a skill and art.\nGPIO Memory-Mapped Interface The documentation for many of the peripherals on-board the Rasperry Pi can be found in Broadcom\u0026rsquo;s BCM2837 ARM Peripherals Manual (or in doc/BCM2837-ARM-Peripherals.pdf). The documentation for GPIO, for example, is on page 89.\nWait, aren\u0026rsquo;t we using a BCM2837 chip?\nIf you open the manual we\u0026rsquo;ve linked you to, you\u0026rsquo;ll see references to the BCM2835 chip everywhere. This is because we\u0026rsquo;ve simply taken the documentation for the BCM2835 chip, fixed relevant errata, and fixed the title to say BCM2837.\nThe BCM2837 and BCM2835 share the same peripherals with the same relative memory-mapped interfaces. The main difference is that the chips differ in their physical memory configuration. This results in the BCM2837 having a peripheral physical base address of 0x3F000000 as opposed to the BCM2835\u0026rsquo;s 0x20000000. But both chips map this range to the peripheral base address of 0x7E000000. In short, a peripheral address 0x7EXXXXXX is at physical address 0x3FXXXXXX on the BCM2837. The \u0026ldquo;BCM2837\u0026rdquo; documentation we\u0026rsquo;ve linked to contains this change.\nFor this assignment, we\u0026rsquo;ll only need to use the following three registers:\nname peripheral address description size read/write GPFSEL1 0x7E200004 GPIO Function Select 1 32 bits R/W GPSET0 0x7E20001C GPIO Pin Output Set 0 32 bits W GPCLR0 0x7E200028 GPIO Pin Output Clear 0 32 bits W We\u0026rsquo;ve copied this information directly from page 90 of the documentation.\nNow, read the documentation for GPFSELn register on pages 91 and 92. We write to this register to set up a pin as an output or input. Which value to which field in register GPFSEL1 must be written so that GPIO pin 16 is set as an output?\nNow, read the documentation for the GPSET0 and GPCLR0 registers on page 95. We write to GPSET0 to set a pin (turn it on) and write to GPCLR0 to clear a pin (turn it off). Which value do we write to which field in these registers to set/clear pin 16?\nWriting the Code The tut/1-blinky/phase3/ directory in the assignment skeleton contains a scaffold for building a binary suitable for running on the Raspberry Pi 3. We won\u0026rsquo;t explain crt0.S, layout.ld, or Makefile for now. Instead, you\u0026rsquo;ll work on blinky.c.\nIn blinky.c, you\u0026rsquo;ll find that we\u0026rsquo;ve declared the physical addresses of the three relevant registers at the top of the file. Your task is to complete the main() function so that GPIO pin 16 is set-up as an output and then continuously set and cleared to blink the LED. We\u0026rsquo;ve also provided rudimentary \u0026ldquo;sleep\u0026rdquo; functions that stall the CPU for roughly the amount of time the function name indicates. You can use these to pause between sets and clears.\nWhen you are ready to test your program, compile it by running make in your shell. If all goes well, this will create the file blinky.bin which is our first bare metal program running on the Pi. To run the program on the Raspberry Pi, copy it as kernel8.img to the microSD, unmount the microSD, and insert the microSD back to your Pi. We provide a convenient script to copy the kernel image to the sdcard - try make install.\nIf your program blinks the led as expected, proceed to phase 4.\nPin function selection, setting, and clearing can each be implemented in one line of code.\nRecall the \u0026lt;\u0026lt;, |, \u0026amp;, and ~ bitwise operators in C.\nRecall that binary/hex numbers in C are written as 0b011 and 0x03, respectively.\nPhase 4: Rusting Away In this phase, you\u0026rsquo;ll write the same program in phase 3, but with Rust! You\u0026rsquo;ll write your code in tut/1-blinky/phase4/src/main.rs.\nAll required programs have already been installed to your system via bin/setup.sh before. Let\u0026rsquo;s double check.\n$ make --version GNU Make 4.1 ... $ rustc --version rustc 1.37.0-nightly (0af8e872e 2019-06-30) $ cargo xbuild --version cargo-xbuild 0.5.20 $ cargo objcopy --version cargo-objcopy 0.1.7 That\u0026rsquo;s it! You have everything ready for this assignment.\nCheck your Rust compiler version\nMake sure your Rust version matches rustc 1.37.0-nightly (0af8e872e 2019-06-30). The toolchain name for this version is nightly-2019-07-01. We will use a few unstable features of Rust from this assignment (e.g., inline assembly), and not matching the compiler version may result in spurious compile error due to the incompatibility.\nWriting the Code To write the required code in tut/1-blinky/phase4/src/main.rs, you\u0026rsquo;ll only need to know the following Rust:\nYou can read and write from a raw pointer (*mut T) using the read_volatile() and write_volatile() methods.\nFor example, if we have the following declarations:\nconst A: *mut u32 = 0x12 as *mut u32; const B: *mut u32 = 0x34 as *mut u32; We can write the 32-bit unsigned integer at address 0x12 to 0x34 with the following:\nB.write_volatile(A.read_volatile()); Local variables can be declared with let variable_name = expression;.\nUsing the A declaration from the previous example, we can read the value at address 0x12 to a local variable value as follows:\nlet value = A.read_volatile() You can call a function fn f(param: usize); with f(123);.\nA loop block can be used to repeat a block infinitely:\nloop { do_this_again_and_again(); } Rust defines the following bitwise operators:\n!: unary bitwise inversion \u0026lt;\u0026lt;: left shift binary operator \u0026gt;\u0026gt;: right shift binary operator |: bitwise OR binary operator \u0026amp;: bitwise AND binary operator You are now ready to implement the blink program in tut/1-blinky/phase4/src/main.rs. Translate your C implementation into Rust in the kmain function. You\u0026rsquo;ll find that we\u0026rsquo;ve declared the physical addresses of the three relevant registers at the top of the file. We\u0026rsquo;ve also provided a rudimentary \u0026ldquo;sleep\u0026rdquo; function that stalls the CPU for roughly the amount of time the function name indicates. You can use the function to pause between sets and clears.\nWhen you are ready to test your program, compile it by running make from the phase4 directory in your shell. If all goes well, this will create the file build/blinky.bin. You can install blinky.bin to the microSD via make install. If your Rust program starts blinking the led, you have successfully completed assignment 0! Proceed to the next phase for submission instructions.\nYour Rust and C code should look very similar.\nSubmission Once you\u0026rsquo;ve completed the tasks above, you\u0026rsquo;re done and ready to submit! Ensure you\u0026rsquo;ve committed your changes. Any uncommitted changes will not be visible to us, thus unconsidered for grading.\nWhen you\u0026rsquo;re ready, push a commit to your GitHub repository with a tag named lab1-done.\n$ git status $ git add -A $ git commit -a -m \u0026#34;yay, lab1 done!\u0026#34; $ git tag lab1-done $ git push --tags ", 
        "url": "\/\/localhost:1313\/post\/lab1\/"
    },
    
    "\/\/localhost:1313\/post\/lab0\/": {
        "title": "Lab 0: Rustlings",
        "tags": ["Lab",],
        "content": " Handed out: Tuesday, January 7, 2020 Due: Monday, January 20, 2020 Introduction Welcome to CS3210! We\u0026rsquo;re really excited that you\u0026rsquo;ve decided to join us for this inaugural incarnation. We hope you have as much fun taking this class as we\u0026rsquo;ve had developing it! And, of course, we hope you learn a ton.\nWe\u0026rsquo;re hoping to do things a little differently in CS3210 than the norm. In particular, we want you to write the majority of the code, and we want your code to execute on real hardware, doing real things. There\u0026rsquo;s going to be very little scaffolding provided for you, and all of your code will target and run on the Raspberry Pi 3/B/B+, a quad-core ARMv8 Cortex-A53 based embedded platform.\nUnlike last serveral years, we\u0026rsquo;ll be programming a toy OS in Rust , \u0026ldquo;a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.\u0026rdquo; You can think of Rust as a successor to C and C++, but it\u0026rsquo;s more useful to think of it as a brand new language with new concepts. Don\u0026rsquo;t try to program in Rust as if it\u0026rsquo;s C, C++, Java, or any other language you\u0026rsquo;re used to. Instead, see it as an opportunity to learn a new way to write software - a new rusty way. By the end of the term, we think you\u0026rsquo;ll agree that Rust helps you write more correct, more reliable, and importantly more secure software, which are the key properties for operating systems!\nYou\u0026rsquo;ll be writing a lot of code in CS3210, though we think that the majority of your time will be spent thinking about what needs to happen. We expect that most assignments will take about 15-20 hours a week to complete, which means you should, under no circumstance, procrastinate in CS3210. Start early, ask questions, visit us at the office hours, and importantly have fun - you\u0026rsquo;ll learn much more if you give yourself a chance to think through hard problems.\nWe\u0026rsquo;re here to answer any and all questions. Please don\u0026rsquo;t hesitate to reach out to us. Best of luck!\nOverview Mastering a programming language takes time. In fact, truly mastering a single programming language takes long time, perhaps our lifetime. In other words, it\u0026rsquo;s unrealistic to assume that we become a true master of Rust in a week\nbut we all hope we can start tinkering anything with Rust at the end of this semester. As a warm up, we will spend sometime to understand syntactic as well as semantic foundation of the Rust programming language by answering a series of questions we prepared.\nTo get set up your environment, let\u0026rsquo;s first install required dependencies and the Rust ecosystems, namely rustc and cargo. We assume that you are doing the assignments on a latest LTS Ubuntu distribution (i.e., Ubuntu 18.04 LTS). If you are not running Ubuntu natively, please check the Tool page to prepare a Ubuntu virtual machine. Also if you are not familiar with git, please first check Pro Git Book .\n$ git clone https://github.com/sslab-gatech/cs3210-rustos-public.git --origin skeleton rustos $ cd rustos # This script automatically setup the environment $ bin/setup.sh ... $ export PATH=$HOME/.cargo/bin:$PATH $ rustc --version rustc 1.37.0-nightly (0af8e872e 2019-06-30) In the repository, we try hard to keep everything in place\nno additional download or dependencies. It looks like: . ├── bin : common binaries/utilities (e.g., objdump for aarch64) ├── doc : reference documents └── tut : tutorial/practices (i.e., no further reuse for later labs) └── 0-rustlings : this contains files for lab0 Rustlings Our goal of lab0 is to guide you to read from Chapter 1 to Chapter 18 of Rust By Example .\nTo check your understanding, we will use Rustlings , which is a neat way to get familiarized with Rust by solving a series of simple exercises. It provides an interactive session of training by comprehending the compiler error messages and resolving it. While doing exercises, you would like to read various chapters of The Rust Book . You can also find more pointers on Rust in the course\u0026rsquo;s reference page.\n$ cd tut/0-rustlings $ ./rustlings help ... SUBCOMMANDS: help Prints this message or the help of the given subcommand(s) hint Returns a hint for the current exercise run Runs/Tests a single exercise verify Verifies all exercises according to the recommended order watch Reruns `verify` when files were edited To start your exercise, you can invoke the watch command that guides you which exercise to work on in a proper order:\n$ ./rustlings watch If you\u0026rsquo;d like, you can also do each exercise (files in exercises/) by invoking ./rustling run [name].\n$ ./rustlings run variables1 ! Compilation of exercises/variables/variables1.rs failed! Compiler error message: error[E0425]: cannot find value `x` in this scope --\u0026gt; exercises/variables/variables1.rs:12:5 | 12 | x = 5; | ^ not found in this scope error[E0425]: cannot find value `x` in this scope --\u0026gt; exercises/variables/variables1.rs:13:36 | 13 | println!(\u0026#34;x has the value {}\u0026#34;, x); | ^ not found in this scope error: aborting due to 2 previous errors For more information about this error, try `rustc --explain E0425`. If you find the exercise too difficult, ask rustlings for hints of the exercise, like below:\n$ rustlings hint variables1 Hint: The declaration on line 12 is missing a keyword that is needed in Rust to create a new variable binding To complete this assignment, ./rusting verify should say all the prepared exercises are successfully completed!\nAssignment Submission We are going to use Georgia Tech\u0026rsquo;s GitHub for the assignment submission in CS3210. After logging into the system, create a repository named rustos. When creating the repository, make it private and do not initialize the repository with a README. Next, give TAs\u0026rsquo; accounts access to your repository for the grading purpose. You should add us in Settings \u0026gt; Collaborators in your repository menu.\nYechan Bae (ybae38) Sujin Park (spark800) Mansour Alharthi (malharthi9) Taesoo Kim (tkim92) Once you have created the repository, inform us via Google Form .\nTo submit your code for lab0, push a commit to the GitHub repository with a tag named lab0-done. We will fetch the assignment code from your repository on each deadline. The following git command samples might be helpful.\n# connect your local repository to GitHub $ git remote add origin https://github.gatech.edu/[id]/rustos $ git push -u origin master # make a commit and publish the update $ git status $ git add -A $ git commit -a -m \u0026#34;yay, lab0 done!\u0026#34; $ git push # submit lab0 $ git tag lab0-done $ git push --tags Grading Policy Your score will be simply calculated based on the submission date of the \u0026ldquo;completed\u0026rdquo; assignment. The meaning of \u0026ldquo;completion\u0026rdquo; is for your repository to be tagged as \u0026ldquo;labN-done\u0026rdquo; (e.g., lab0-done). If your code in the repo passes all test cases provided as part of the assignment on time, you will get the maximum score (i.e., 100) for the corresponding lab. If you are late in submitting the completed assignment, your score of the lab will be max(0, 100*[#passes/#testcases] - [#late-day]*10), in theory.\nHowever, we give a week (7 days in total for all labs) of a grace period, which you can use without even letting us know! For example, if you are one-day late in submitting the first lab (i.e., the completed lab0), you still get 100 points for the lab but your grace period is first reduced to 6 days. Once you don\u0026rsquo;t have any grace period left, the above rule for the lab effectively takes place. For example, if you don\u0026rsquo;t have any grace period but again late in submitting the lab one day, your score would be max(0, 100 - 1*10), so 90 for the completed lab.\nWe will regularly fetch your repository after the initial deadline, and your score and the grace period will be automatically updated on canvas. Please send us an email if you made a late change to the assignment and your score had not updated for a week.\nWe really hope all the students in this class get A!\n", 
        "url": "\/\/localhost:1313\/post\/lab0\/"
    },
    
    "\/\/localhost:1313\/categories\/": {
        "title": "Categories",
        "tags": [],
        "content": "", 
        "url": "\/\/localhost:1313\/categories\/"
    },
    
}
</script>
<script defer src="/js/lunr.js"></script>
<script defer src="/js/search.js"></script>

</footer>

</body>
</html>

