<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"}>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#1b1b1b" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1b" />

    <meta name="description" content="Lab 3: Shell and Bootloader Phase 1">

    
        <title>Lab 3: Shell and Bootloader Phase 1 | OS Labs</title>
    

    
    <style>
        :root {
          --background: #1b1b1b;
        }
        @media (prefers-color-scheme: dark) {
          :root {
            --background: #1b1b1b;
          }
        }
        html {
            background-color: var(--background);
        }
        body {
            background-color: var(--background);
        }
    </style>

    
    <link rel="stylesheet" type="text/css" href="/style.min.8b321058a79ec67e36fab2e8ec98f882ec83a2fb260aa37f50936110b5fbcd02.css" media="all">
  </head>

  <body>
        
        <nav>
          <ul class="menu">
            
                <li><a tabindex="-1" class="menu-link" href="/">Home</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/tags">Tags</a></li>
            
          </ul>
        </nav>
        




<div id="single-header">
  <h1>
    Lab 3: Shell and Bootloader Phase 1
  </h1>
  <div id="single-meta">
    
    
        <span class="datesub">Jan 28, 2025 &nbsp;&nbsp; m. Feb 9, 2025</span>
      
<span id="tags">
  &nbsp;&nbsp;
   <span>
    <a href="/tags/lab/">#lab</a>
  </span>&nbsp;</span>


  </div>
</div>



<aside class="hidden lg:block toc " id="tableOfContentContainer">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#phase-1-oxidation">Phase 1: Oxidation</a>
      <ul>
        <li><a href="#subphase-a-stackvec">Subphase A: <code>StackVec</code></a></li>
        <li><a href="#subphase-b-volatile">Subphase B: <code>volatile</code></a></li>
        <li><a href="#subphase-c-xmodem">Subphase C: <code>xmodem</code></a></li>
        <li><a href="#subphase-d-ttywrite">Subphase D: <code>ttywrite</code></a></li>
      </ul>
    </li>
  </ul>
</nav>
</aside>



<main><h2 id="introduction">Introduction</h2>
<p>In this assignment, you will write useful utilities, libraries, and a
simple shell for Raspberry Pi. This is just a single phase of this exercise
and we&rsquo;ll be going over the rest of them in the incoming weeks.</p>


<style type="text/css">
    .box-shortcode {
      padding: 1.2em;
      padding-top: 1em;
      line-height: 1.54em;
      margin-top: 1em;
      margin-bottom: 2em;
      border-radius: 3px;
      color: var(--text);
      background: #f3ebe850;
    }

    .box-title {
      margin: -18px -18px 12px;
      padding: 4px 18px;
      border-radius: 3px 3px 0 0;
      font-weight: 700;
      color: var(--text);
      background: #6ab0de;
    }
    .box-shortcode.warning .box-title {
      background: #ff6b6b;
    }
    .box-shortcode.warning {
      background: #ff6b6b4f;
    }
    .box-shortcode.info .box-title {
      background: #0089e488;
    }
    .box-shortcode.info {
      background: #0089e41c;
    }
    .box-shortcode.important .box-title {
      background: #f7ec2c;
    }
    .box-shortcode.important {
      background: #f7ec2c7d;
    }
    .box-shortcode.tip .box-title {
      background: #a3ffa34d;
    }
    .box-shortcode.tip {
      background: #a3ffa34d;
    }
    .box-shortcode.question .box-title {
      background: #ffffff;
    }
    .box-shortcode.question {
      background: #786a9e;
    }
    .icon-box {
      display: inline-flex;
      align-self: center;
      margin-right: 8px;
    }
    .icon-box img,
    .icon-box svg {
      height: 1em;
      width: 1em;
      fill: var(--text-dim);
    }
    .icon-box img,
    .icon-box.baseline svg {
      top: 0.125em;
      position: relative;
    }
    .box-shortcode p {
      margin-bottom: 0.6em;
    }
    .box-shortcode p:first-of-type {
      display: inline;
    }
    .box-shortcode p:nth-of-type(2) {
      margin-top: 0.6em;
    }
    .box-shortcode p:last-child {
      margin-bottom: 0;
    }
  </style>

  
  <svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg">
    <symbol id="tip-box" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet">
      <path
        d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/>
    </symbol>
    <symbol id="important-box" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet">
      <path
        d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/>
    </symbol>
    <symbol id="warning-box" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet">
      <path
        d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/>
    </symbol>
    <symbol id="info-box" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet">
      <path
        d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"/>
    </symbol>
    <symbol id="question-box" viewBox="0 0 16 16" preserveAspectRatio="xMidYMid meet">
      <path
      d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.496 6.033h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286a.237.237 0 0 0 .241.247zm2.325 6.443c.61 0 1.029-.394 1.029-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94 0 .533.425.927 1.01.927z"/>
    </symbol>
  </svg>
<div class="box box-shortcode info" >
    <span class="icon-box baseline">
      <svg><use href="#info-box"></use></svg>
    </span>
    <p>Please insure you&rsquo;ve setup the environment as described on
<a href="/post/env_setup/#setting-up-the-environment" >Tools page</a>
.</p>
  </div>

<p>This is the directory structure of our repository.
The directories you will be working on this lab section are
marked with <code>*</code>.</p>
<pre tabindex="0"><code>.
├── bin : common binaries/utilities
├── ext : external files (e.g., resources for testing)
├── boot : bootloader *
├── kern : the main os kernel *
└── lib  : required libraries
    ├── pi *
    ├── shim
    ├── stack-vec *
    ├── ttywrite *
    ├── volatile *
    └── xmodem *
</code></pre><p>We recommend the following directory structure for your assignments.
Confirm that your directories are properly laid out by running <code>make</code>
inside the <code>kern</code> directory now. If all is well, the command will
return successfully.
If everything is good, feel free to explore the contents of the repository.</p>
<h2 id="phase-1-oxidation">Phase 1: Oxidation</h2>
<p>In this phase, you will write two libraries, one command-line
utility, and review one library. You will be working in the
<code>stack-vec</code>, <code>volatile</code>, <code>ttywrite</code>, and <code>xmodem</code> skeleton
subdirectories located in <code>lib</code> directory.</p>
<p>All projects are being managed with Cargo. You will find the
following <code>cargo</code> commands useful:</p>
<ul>
<li><code>cargo build</code> - build an application or library</li>
<li><code>cargo test</code> - test an application or library</li>
<li><code>cargo run</code> - run an application</li>
<li><code>cargo run -- $flags</code> - run an application and pass arbitrary flags to it</li>
</ul>
<p>For more information on using Cargo and how Cargo works, see the
<a href="https://doc.rust-lang.org/cargo/index.html"  target="_blank" rel="noreferrer nofollow">Cargo Book</a>
.</p>
<h3 id="subphase-a-stackvec">Subphase A: <code>StackVec</code></h3>
<p>One important facility that operating systems provide is memory
allocation. When a C, Rust, Java, Python, or just about <em>any</em>
application calls <code>malloc()</code> and <code>malloc()</code> has run out of
memory from the operating system, a system call is eventually made
to request additional memory. The operating system determines if
there is memory available, and if so, fulfills the request for
memory.</p>


<div class="box box-shortcode info" >
    <span class="icon-box baseline">
      <svg><use href="#info-box"></use></svg>
    </span>
    <p>Memory allocation is a complicated story.</p>
<p>In practice, modern operating systems like Linux have a
complicated relationship with memory allocation. For instance,
as an optimization, most requests for memory allocation are
only &ldquo;virtually&rdquo; handled: no physical memory is actually
allocated until the application tries to use the newly
allocated memory. Nonetheless, most operating systems aim to
provide the <em>illusion</em> that they are allocating memory in the
simplistic manner we&rsquo;ve described. Operating systems are master
liars.</p>
  </div>

<p>Heap-allocated structures like <code>Vec</code>, <code>String</code>, and <code>Box</code>
internally call <code>malloc()</code> to allocate memory as necessary. This
means that these structures require operating system support to
function. In particular, they require the operating system to
support memory allocation. We haven&rsquo;t yet started writing our
operating system, so clearly there&rsquo;s no memory allocation support
for our tiny bare-metal programs to make use of. As such, we can&rsquo;t
use heap-allocated structures like <code>Vec</code> until our operating
system is further along.</p>
<p>This is a real shame because <code>Vec</code> is a nice abstraction! It
allows us to think about <code>push</code>ing and <code>pop</code>ing elements
without having to keep track of memory ourselves. <em>How we can get
the benefits of the</em> <code>Vec</code> <em>abstraction without supporting memory
allocation?</em></p>
<p>One common technique is to <em>pre-allocate</em> memory and then hand
that memory to a structure to abstract away. Some ways to
pre-allocate memory include using <code>static</code> declarations to set
apart memory in the static section of a binary or through stack
allocations from local variable declarations. In any case, the
allocations is of a fixed, predetermined size.</p>
<p>In this subphase, you will implement the <code>StackVec</code> structure, a
structure that exposes a <code>Vec</code>-like API when given pre-allocated
memory. You will use the <code>StackVec</code> type later in phase 2 when
implementing a shell for your Raspberry Pi. You will work in the
<code>lib/stack-vec</code> skeleton subdirectory. The subdirectory contains the
following files:</p>
<ul>
<li><code>Cargo.toml</code> - configuration file for Cargo</li>
<li><code>src/lib.rs</code> - where you will write your code</li>
<li><code>src/tests.rs</code> - tests that will run when <code>cargo test</code> is
called</li>
</ul>
<h4 id="the-stackvec-interface">The <code>StackVec</code> Interface</h4>
<p>A <code>StackVec&lt;T&gt;</code> is created by calling <code>StackVec::new()</code>,
passing in a mutable slice to values of any type <code>T</code>. The
<code>StackVec&lt;T&gt;</code> type implements many of the methods that
<a href="https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html"  target="_blank" rel="noreferrer nofollow">Vec</a>

implements and is used in much the same way. Here&rsquo;s an example of
a <code>StackVec&lt;u8&gt;</code> being used:</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ed8796">let</span> <span style="color:#c6a0f6">mut</span> storage <span style="color:#91d7e3;font-weight:bold">=</span> [<span style="color:#f5a97f">0</span><span style="color:#c6a0f6">u8</span>; <span style="color:#f5a97f">10</span>];
</span></span><span style="display:flex;"><span><span style="color:#ed8796">let</span> <span style="color:#c6a0f6">mut</span> vec <span style="color:#91d7e3;font-weight:bold">=</span> StackVec::new(<span style="color:#91d7e3;font-weight:bold">&amp;</span><span style="color:#c6a0f6">mut</span> storage);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#c6a0f6">for</span> i <span style="color:#c6a0f6">in</span> <span style="color:#f5a97f">0</span><span style="color:#91d7e3;font-weight:bold">..</span><span style="color:#f5a97f">10</span> {
</span></span><span style="display:flex;"><span>    vec.push(i <span style="color:#91d7e3;font-weight:bold">*</span> i).expect(<span style="color:#a6da95">&#34;can push 10 times&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#c6a0f6">for</span> (i, v) <span style="color:#c6a0f6">in</span> vec.iter().enumerate() {
</span></span><span style="display:flex;"><span>    <span style="color:#8aadf4">assert_eq!</span>(<span style="color:#91d7e3;font-weight:bold">*</span>v, (i <span style="color:#91d7e3;font-weight:bold">*</span> i) <span style="color:#c6a0f6">as</span> <span style="color:#ed8796">u8</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ed8796">let</span> last_element <span style="color:#91d7e3;font-weight:bold">=</span> vec.pop().expect(<span style="color:#a6da95">&#34;has elements&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#8aadf4">assert_eq!</span>(last_element, <span style="color:#f5a97f">9</span> <span style="color:#91d7e3;font-weight:bold">*</span> <span style="color:#f5a97f">9</span>);
</span></span></code></pre></div><p>We&rsquo;ve declared the <code>StackVec</code> structure for you already:</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#c6a0f6">pub</span> <span style="color:#c6a0f6">struct</span> <span style="color:#eed49f">StackVec</span><span style="color:#91d7e3;font-weight:bold">&lt;</span><span style="color:#8aadf4">&#39;a</span>, T: <span style="color:#8aadf4">&#39;a</span><span style="color:#91d7e3;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span>    storage: <span style="color:#c6a0f6">&amp;</span><span style="color:#8aadf4">&#39;a</span> <span style="color:#eed49f">mut</span> [T],
</span></span><span style="display:flex;"><span>    len: <span style="color:#ed8796">usize</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="understanding-stackvec">Understanding <code>StackVec</code></h4>
<p>The following questions test your understanding about the
<code>StackVec</code> interface:</p>


<div class="box box-shortcode question" >
    <span class="icon-box baseline">
      <svg><use href="#question-box"></use></svg>
    </span>
    <p>Why does <code>push</code> return a <code>Result</code>? (push-fails)</p>
<p>The <code>push</code> method from <code>Vec</code> in the standard library has
no return value, but the <code>push</code> method from our
<code>StackVec</code> does: it returns a <code>Result</code> indicating that
it can fail. Why can <code>StackVec::push()</code> fail where
<code>Vec::push()</code> does not?</p>
  </div>



<div class="box box-shortcode question" >
    <span class="icon-box baseline">
      <svg><use href="#question-box"></use></svg>
    </span>
    <p>Why is the <code>'a</code> bound on <code>T</code> required? (lifetime)</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#c6a0f6">struct</span> <span style="color:#eed49f">StackVec</span><span style="color:#91d7e3;font-weight:bold">&lt;</span><span style="color:#8aadf4">&#39;a</span>, T<span style="color:#91d7e3;font-weight:bold">&gt;</span> { buffer: <span style="color:#c6a0f6">&amp;</span><span style="color:#8aadf4">&#39;a</span> <span style="color:#eed49f">mut</span> [T], len: <span style="color:#ed8796">usize</span> }
</span></span></code></pre></div><p>Rust automatically enforces the bound <code>T: 'a</code> and will complain
if type <code>T</code> lives shorter than the lifetime <code>'a</code>. For instance,
if <code>T</code> is <code>&amp;'b str</code> and <code>'b</code> is strictly shorter than <code>'a</code>,
Rust won&rsquo;t allow you to create the instance of <code>StackVec&lt;'a, &amp;'b str&gt;</code>.</p>
<p>Why is the bound required? What could go wrong if the bound
wasn&rsquo;t enforced by Rust?</p>
  </div>



<div class="box box-shortcode question" >
    <span class="icon-box baseline">
      <svg><use href="#question-box"></use></svg>
    </span>
    <p>Why does <code>StackVec</code> require <code>T: Clone</code> to <code>pop()</code>? (clone-for-pop)</p>
<p>The <code>pop</code> method from <code>Vec&lt;T&gt;</code> in the standard library is
implemented for all <code>T</code>, but the <code>pop</code> method from our
<code>StackVec</code> is only implemented when <code>T</code> implements the
<code>Clone</code> trait. Why might that be? What goes wrong when the
bound is removed?</p>
  </div>

<h4 id="implementing-stackvec">Implementing <code>StackVec</code></h4>
<p>Implement all of the <code>unimplemented!()</code> <code>StackVec</code> methods in
<code>stack-vec/src/lib.rs</code>. Each method is documented in the source
code. We have also provided tests in <code>src/tests.rs</code> that help
ensure that your implementations are correct. You can run these
tests with <code>cargo test</code>. You&rsquo;ll also need to implement the
<code>Deref</code>, <code>DerefMut</code>, and <code>IntoIterator</code> traits for
<code>StackVec</code> as well as the <code>IntoIterator</code> trait for
<code>&amp;StackVec</code> for all of the <code>cargo test</code> tests to pass. Once
you feel confident that you implementation is correct and have
answered this subphase&rsquo;s questions, proceed to the next subphase.</p>


<div class="box box-shortcode question" >
    <span class="icon-box baseline">
      <svg><use href="#question-box"></use></svg>
    </span>
    <p>Which tests make use of the <code>Deref</code> implementations? (deref-in-tests)</p>
<p>Read through the tests we have provided in <code>src/tests.rs</code>.
Which tests would fail to compile if the <code>Deref</code>
implementation did not exist? What about the <code>DerefMut</code>
implementation? Why?</p>
  </div>



<div class="box box-shortcode warning" >
    <span class="icon-box baseline">
      <svg><use href="#warning-box"></use></svg>
    </span>
    <p>Our unit tests are incomplete!</p>
<p>Our unit tests provide a <em>baseline</em> truth, but they are not
complete! We will run additional tests when we grade your
assignment. You may wish to find the gaps in our tests and add
additional tests of your own to fill them.</p>
  </div>

<h3 id="subphase-b-volatile">Subphase B: <code>volatile</code></h3>
<p>In this subphase, you will learn about volatile memory accesses,
read the source code in the <code>volatile</code> skeleton subdirectory,
and answer questions related to the source code. You won&rsquo;t be
writing any code in this subphase.</p>
<p>Like operating systems, compilers are masters at making things
<em>appear</em> as if they&rsquo;re doing what you think they&rsquo;re doing when in
reality, they&rsquo;re really doing something entirely different for the
sake of optimization. One such optimization is dead-access
elimination: compilers remove memory accesses (reads and writes)
when they can prove doing so has no observable effect on the
program&rsquo;s execution. For instance, consider the following program:</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>fn <span style="color:#8aadf4">f</span>() {
</span></span><span style="display:flex;"><span>    let mut x <span style="color:#91d7e3;font-weight:bold">=</span> <span style="color:#f5a97f">0</span>;
</span></span><span style="display:flex;"><span>    let y <span style="color:#91d7e3;font-weight:bold">=</span> <span style="color:#91d7e3;font-weight:bold">&amp;</span>mut x;
</span></span><span style="display:flex;"><span>    <span style="color:#91d7e3;font-weight:bold">*</span>y <span style="color:#91d7e3;font-weight:bold">=</span> <span style="color:#f5a97f">10</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The compiler can completely eliminate the write to <code>*y</code> by
reasoning that <code>*y</code> is never read after it&rsquo;s written. The
compiler concludes that as a result, the write cannot possibly
effect the program, and eliminates it in the compiled binary. For
the same reason, it can then proceed to eliminate the declaration
for <code>y</code>, the declaration for <code>x</code>, and calls to <code>f()</code>
entirely.</p>
<p>These kinds of optimizations are almost exclusively beneficial:
they speed up our programs without affecting their outcome. But
sometimes these optimizations can have unintended consequences.
Say, for example, that <code>y</code> was pointing to a write-only
memory-mapped register. Then, writes to <code>*y</code> <em>will</em> have
observable effects <em>without</em> having to read <code>*y</code> thereafter. If
the compiler is not aware of this, it will optimize away these
writes, and our program will not function correctly.</p>
<p>How can we force the compiler to keep around reads and writes that
appear to have no effects at the source code level? This is where
<code>volatile</code> memory accesses come in: the compiler promises <em>not</em>
to optimize away volatile memory accesses. So if we want to ensure
a read or write occurs at runtime, we must perform a volatile
memory access.</p>
<h4 id="rusty-volatile">Rusty <code>volatile</code></h4>
<p>In Rust, we use the
<a href="https://doc.rust-lang.org/nightly/core/ptr/fn.read_volatile.html"  target="_blank" rel="noreferrer nofollow">read_volatile</a>

and
<a href="https://doc.rust-lang.org/nightly/core/ptr/fn.write_volatile.html"  target="_blank" rel="noreferrer nofollow">write_volatile</a>

methods to perform volatile reads and writes to a raw pointer.</p>


<div class="box box-shortcode info" >
    <span class="icon-box baseline">
      <svg><use href="#info-box"></use></svg>
    </span>
    <p>What&rsquo;s a <em>raw</em> pointer?</p>
<p>By now you&rsquo;re familiar with references (<code>&amp;T</code> and <code>&amp;mut T</code>).
A raw pointer in Rust (<code>*const T</code> and <code>*mut T</code>) is a
&ldquo;reference&rdquo; that isn&rsquo;t tracked with lifetimes by Rust&rsquo;s borrow
checker. Because of this, read or writes to these pointers may
be invalid, just as in C. Rust considers them <code>unsafe</code>, and
code that reads or writes them must be annotated with
<code>unsafe</code> to indicate this. You can read more about <a href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html"  target="_blank" rel="noreferrer nofollow">raw
pointers in the
rustdocs</a>
.</p>
  </div>

<p>Calling
<a href="https://doc.rust-lang.org/nightly/core/ptr/fn.read_volatile.html"  target="_blank" rel="noreferrer nofollow">read_volatile</a>

and
<a href="https://doc.rust-lang.org/nightly/core/ptr/fn.write_volatile.html"  target="_blank" rel="noreferrer nofollow">write_volatile</a>

every time we want to perform a volatile read or write is error
prone and frustrating. Thankfully Rust provides us the tools to
make this easier and safer. Ideally we can simply declare a
pointer as volatile (as in C) and ensure that every read or write
thereafter is volatile. Even better, we should be able declare a
pointer as read-only, write-only (unlike in C), or read/write and
ensure only the appropriate memory accesses can be made.</p>
<h4 id="introducing-volatile-readvolatile-writevolatile-and-uniquevolatile">Introducing <code>Volatile</code>, <code>ReadVolatile</code>, <code>WriteVolatile</code>, and <code>UniqueVolatile</code></h4>
<p>The <code>volatile</code> crate in the <code>volatile/</code> skeleton subdirectory
implements these four types that allow us to do just this. Read
the documentation for these types now by running
<code>cargo doc --open</code> inside of the <code>volatile/</code> directory.</p>


<div class="box box-shortcode info" >
    <span class="icon-box baseline">
      <svg><use href="#info-box"></use></svg>
    </span>
    <p>Why does <code>Unique&lt;Volatile&gt;</code> exist? (unique-volatile)</p>
<p>Both <code>Volatile</code> and <code>Unique&lt;Volatile&gt;</code> allow read/write
volatile accesses to an underlying pointer. According to the
documentation, what is the difference between these two
types?</p>
  </div>

<p>Now open the source code in <code>src/lib.rs</code>, <code>src/traits.rs</code>,
and <code>src/macros.rs</code>. Read through the source code to the
best of your abilities. When you&rsquo;re ready, answer the following
questions. Once you have answered these questions, you&rsquo;re ready
to move on to the next subphase.</p>


<div class="box box-shortcode info" >
    <span class="icon-box baseline">
      <svg><use href="#info-box"></use></svg>
    </span>
    <p>What&rsquo;s with <code>#[repr(C)]</code>?</p>
<p>The <code>#[repr(C)]</code> annotation forces Rust to lay out the
structure&rsquo;s fields in the same way that C would. In general,
Rust optimizes the order and padding between fields of
structures in an unspecified way. When we cast a raw address to
a pointer to a structure, we typically have a very specific
memory layout in mind. The <code>#[repr(C)]</code> annotation lets us
confide that Rust will arrange the structure as we intend it
to, not as it wishes.</p>
  </div>



<div class="box box-shortcode question" >
    <span class="icon-box baseline">
      <svg><use href="#question-box"></use></svg>
    </span>
    <p>How are read-only and write-only accesses enforced? (enforcing)</p>
<p>The <code>ReadVolatile</code> and <code>WriteVolatile</code> types make it
impossible to write and read, respectively, the underlying
pointer. How do they accomplish this?</p>
  </div>



<div class="box box-shortcode question" >
    <span class="icon-box baseline">
      <svg><use href="#question-box"></use></svg>
    </span>
    <p>What do the macros do? (macros)</p>
<p>What do the <code>readable!</code>, <code>writeable!</code>, and
<code>readable_writeable!</code> macros do?</p>
  </div>

<h3 id="subphase-c-xmodem">Subphase C: <code>xmodem</code></h3>
<p>In this subphase, you will implement the XMODEM file transfer
protocol in the <code>xmodem</code> library in the <code>xmodem/</code> skeleton
subdirectory. You will primarily be working in
<code>xmodem/src/lib.rs</code>.</p>
<p>XMODEM is a simple file transfer protocol originally developed in
1977. It features packet checksums, cancellation, and automatic
retries. It is widely implemented and used for transfers through
serial interfaces. Its best feature, however, is its simplicity.
For more about its history, see the <a href="https://en.wikipedia.org/wiki/XMODEM"  target="_blank" rel="noreferrer nofollow">XMODEM Wikipedia
article</a>
.</p>
<p>We will use the XMODEM protocol to transfer files to the Raspberry
Pi. While we could use existing implementations of the XMODEM
protocol to <em>send</em> data to the Pi, we will still need to write our
own receiver. So, while we&rsquo;re at it, we&rsquo;ll be implementing XMODEM
transmission as well.</p>
<h4 id="the-protocol">The Protocol</h4>
<p>The XMODEM protocol is described in detail in the <a href="https://cs140e.sergio.bz/assignments/1-shell/data/XMODEM.txt"  target="_blank" rel="noreferrer nofollow">Understanding
The X-Modem File Transfer
Protocol</a>

txt file. We describe it again here, for posterity.</p>


<div class="box box-shortcode warning" >
    <span class="icon-box baseline">
      <svg><use href="#warning-box"></use></svg>
    </span>
    <p>Do not base your implementation off of Wikipedia&rsquo;s explanation!</p>
<p>While Wikipedia&rsquo;s explanation is helpful at a high level, many
of the details presented there are different from the protocol
we&rsquo;ll be implementing here. As such, do not use the article as
a reference for this subphase.</p>
  </div>

<p>XMODEM is a binary protocol: bytes are sent and received in the
raw. It is also &ldquo;half duplex&rdquo;: at any point in time, either the
sender or receiver is sending data, but never both. Finally it is
packet-based: data is separated into 128 byte chunks known as
packets. The protocol dictates which bytes are sent when, what
they mean, and how they&rsquo;re interpreted.</p>
<p>First, we define a few constants:</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#c6a0f6">const</span> <span style="color:#eed49f">SOH</span>: <span style="color:#ed8796">u8</span> <span style="color:#91d7e3;font-weight:bold">=</span> <span style="color:#f5a97f">0x01</span>;
</span></span><span style="display:flex;"><span><span style="color:#c6a0f6">const</span> <span style="color:#eed49f">EOT</span>: <span style="color:#ed8796">u8</span> <span style="color:#91d7e3;font-weight:bold">=</span> <span style="color:#f5a97f">0x04</span>;
</span></span><span style="display:flex;"><span><span style="color:#c6a0f6">const</span> <span style="color:#eed49f">ACK</span>: <span style="color:#ed8796">u8</span> <span style="color:#91d7e3;font-weight:bold">=</span> <span style="color:#f5a97f">0x06</span>;
</span></span><span style="display:flex;"><span><span style="color:#c6a0f6">const</span> <span style="color:#eed49f">NAK</span>: <span style="color:#ed8796">u8</span> <span style="color:#91d7e3;font-weight:bold">=</span> <span style="color:#f5a97f">0x15</span>;
</span></span><span style="display:flex;"><span><span style="color:#c6a0f6">const</span> <span style="color:#eed49f">CAN</span>: <span style="color:#ed8796">u8</span> <span style="color:#91d7e3;font-weight:bold">=</span> <span style="color:#f5a97f">0x18</span>;
</span></span></code></pre></div><p>To start the file transfer, the receiver sends a <code>NAK</code> byte
while the sender waits for a <code>NAK</code> byte. Once the sender has
received the <code>NAK</code> byte, packet transmission begins. The
receiver only sends a <code>NAK</code> byte to begin the file transfer, not
once for every packet.</p>
<p>Once file transfer has begun, each packet&rsquo;s transmission and
reception is identical. Packets are numbered in sequential order
starting at <code>1</code> and wrap around to <code>0</code> after <code>255</code>.</p>
<figure><img src="./res/xmodem-diagram.svg" width="300px"><figcaption>
      <h4>XMODEM protocol diagram</h4>
    </figcaption>
</figure>

<p>To send a packet, the sender:</p>
<ol>
<li>
<p>Sends an <code>SOH</code> byte.</p>
</li>
<li>
<p>Sends the packet number.</p>
</li>
<li>
<p>Sends the 1s complement of the packet number (<code>255 - $packet_number</code>).</p>
</li>
<li>
<p>Sends the packet itself.</p>
</li>
<li>
<p>Sends the packet checksum.</p>
<ul>
<li>The checksum is the sum of all of the bytes in the packet mod 256.</li>
</ul>
</li>
<li>
<p>Reads a byte from the receiver.</p>
<ul>
<li>If the byte is <code>NAK</code>, transmission for the same packet is
retried up to 10 times.</li>
<li>If the byte is <code>ACK</code>, the next packet is sent.</li>
</ul>
</li>
</ol>
<p>The receive a packet, the receiver performs the inverse:</p>
<ol>
<li>
<p>Waits for an <code>SOH</code> or <code>EOT</code> byte from the sender.</p>
<ul>
<li>If a different byte is received, the receiver cancels the transfer.</li>
<li>If an <code>EOT</code> byte is received, the receiver performs end of transmission.</li>
</ul>
</li>
<li>
<p>Reads the next byte and compares it to the current packet number.</p>
<ul>
<li>If the wrong packet number is received, the receiver cancels the transfer.</li>
</ul>
</li>
<li>
<p>Reads the next byte and compares it to the 1s complement of the packet number.</p>
<ul>
<li>If the wrong number is received, the receiver cancels the transfer.</li>
</ul>
</li>
<li>
<p>Reads a packet (128 bytes) from the sender.</p>
</li>
<li>
<p>Computes the checksum for the packet.</p>
<ul>
<li>The checksum is the sum of all of the bytes in the packet mod 256.</li>
</ul>
</li>
<li>
<p>Reads the next byte and compares it to the computed checksum.</p>
<ul>
<li>If the checksum differs, sends a <code>NAK</code> byte and retries reception
for the same packet.</li>
<li>If the checksum is the same, sends an <code>ACK</code> byte and receives
the next packet.</li>
</ul>
</li>
</ol>
<p>To cancel a transfer, a <code>CAN</code> byte is sent by either the
receiver or sender. When either side receives a <code>CAN</code> byte, it
errors out, aborting the connection.</p>
<p>To end the transmission, the sender:</p>
<ol>
<li>Sends an <code>EOT</code> byte.</li>
<li>Waits for a <code>NAK</code> byte. If a different byte is received, the
sender errors out.</li>
<li>Sends a second <code>EOT</code> byte.</li>
<li>Waits for an <code>ACK</code> byte. If a different byte is received, the
sender errors out.</li>
</ol>
<p>To end the transmission, the receiver performs the following after
receiving the first <code>EOT</code>:</p>
<ol>
<li>Sends a <code>NAK</code> byte.</li>
<li>Waits for a second <code>EOT</code> byte. If a different byte is
received, the receiver cancels the transfer.</li>
<li>Sends an <code>ACK</code> byte.</li>
</ol>
<h4 id="implementing-xmodem">Implementing XMODEM</h4>
<p>We have provided an unfinished implementation of the XMODEM
protocol in the <code>xmodem</code> skeleton subdirectory. Your task is to
complete the implementation by writing the <code>expect_byte</code>,
<code>expect_byte_or_cancel</code>, <code>read_packet</code>, and <code>write_packet</code>
methods in <code>src/lib.rs</code>. Your implementations should make use of
the internal state of the <code>Xmodem</code> type: <code>packet</code> and
<code>started</code>. We recommend reading over the existing code before
starting.</p>
<p>You should begin by implementing the <code>expect_byte</code> and
<code>expect_byte_or_cancel</code> methods. You should then make use of all
four of the helper methods (including <code>read_byte</code> and
<code>write_byte</code>) to implement <code>read_packet</code> and <code>write_packet</code>.
To see how these methods are used, read the <code>transmit</code> and
<code>receive</code> implementations which transmit or receive a complete
data stream using XMODEM via these methods. Be mindful of the
specifications in the doc-comments. You can test your
implementation using <code>cargo test</code>. Once you are confident that
your implementation is correct, proceed to the next subphase.</p>


<div class="box box-shortcode warning" >
    <span class="icon-box baseline">
      <svg><use href="#warning-box"></use></svg>
    </span>
    <p>Do not use any additional items from <code>std</code>.</p>
<p>Your implementation should only use items from <code>shim::io</code>. It
should not use other items from <code>std</code> or any other libraries.</p>
  </div>



<div class="box box-shortcode tip" >
    <span class="icon-box baseline">
      <svg><use href="#tip-box"></use></svg>
    </span>
    <p>Our reference implementations for <code>{read,write}_packet</code>
are roughly 43 lines of code each.</p>
  </div>



<div class="box box-shortcode tip" >
    <span class="icon-box baseline">
      <svg><use href="#tip-box"></use></svg>
    </span>
    <p>The
<a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html"  target="_blank" rel="noreferrer nofollow">io::Read</a>

and
<a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html"  target="_blank" rel="noreferrer nofollow">io::Write</a>

rustdocs will be useful.</p>
  </div>



<div class="box box-shortcode tip" >
    <span class="icon-box baseline">
      <svg><use href="#tip-box"></use></svg>
    </span>
    <p>Use the <code>?</code> operator generously.</p>
  </div>



<div class="box box-shortcode tip" >
    <span class="icon-box baseline">
      <svg><use href="#tip-box"></use></svg>
    </span>
    <p>The test source code can be a helpful guide.</p>
  </div>



<div class="box box-shortcode tip" >
    <span class="icon-box baseline">
      <svg><use href="#tip-box"></use></svg>
    </span>
    <p>You can use <code>ioerr!</code> macro to make and return a new <code>io::Error</code> easily.
Please refer <code>shim/src/macros.rs</code> to find more macros which can be useful.</p>
  </div>

<h3 id="subphase-d-ttywrite">Subphase D: <code>ttywrite</code></h3>
<p>In this subphase, you will write a command line utility,
<code>ttywrite</code>, that will allow you to send data to your Raspberry
Pi in the raw or via the XMODEM protocol. You will use your
<code>xmodem</code> library from the previous subphase in your
implementation. You will write your code in
<code>ttywrite/src/main.rs</code>. To test your <code>ttywrite</code>
implementation, use the provided <code>test.sh</code> script.</p>


<div class="box box-shortcode info" >
    <span class="icon-box baseline">
      <svg><use href="#info-box"></use></svg>
    </span>
    <p>What is a serial device?</p>
<p>A serial device is any device that accepts communication one
bit at a time. This is known as <em>serial communication</em>. In
contrast, in <em>parallel communication</em> multiple bits are being
transferred at any point in time in parallel. We will be
communicating with our Raspberry Pi via its UART device, a
serial communication device.</p>
  </div>



<div class="box box-shortcode info" >
    <span class="icon-box baseline">
      <svg><use href="#info-box"></use></svg>
    </span>
    <p>What is a <em>TTY</em>?</p>
<p>A <em>TTY</em> is a &ldquo;teletypewriter&rdquo;. It is a vestigial term that was
adopted in computing to describe computer terminals. The term
later become more general, coming to describe any device
intended to be communicated with over serial. For this reason,
your computer calls the device mapping to your Raspberry Pi a
TTY.</p>
  </div>

<h4 id="command-line-interface">Command-Line Interface</h4>
<p>The skeleton code we have provided for <code>ttywrite</code> already parses
and validates command-line arguments. To do so, it uses the
<a href="https://github.com/TeXitoi/structopt"  target="_blank" rel="noreferrer nofollow">structopt</a>
 crate from
<a href="https://crates.io/"  target="_blank" rel="noreferrer nofollow">crates.io</a>
 which itself uses
<a href="https://clap.rs/"  target="_blank" rel="noreferrer nofollow">clap</a>
. You&rsquo;ll notice that we list it as a
dependency in the <code>Cargo.toml</code> file.
<a href="https://github.com/TeXitoi/structopt"  target="_blank" rel="noreferrer nofollow">structopt</a>
 works through
code generation. We simply annotate a structure and its fields
with a declaration of our command-line arguments and
<a href="https://github.com/TeXitoi/structopt"  target="_blank" rel="noreferrer nofollow">structopt</a>
 generates the
code to actually parse the command-line flags.</p>
<p>To see the interface that
<a href="https://github.com/TeXitoi/structopt"  target="_blank" rel="noreferrer nofollow">structopt</a>
 generates,
call the application with <code>--help</code>. Remember that you can pass
arbitrary flags when using <code>cargo run</code>: <code>cargo run -- --help</code>.
Take a look at the interface now. Then, take a look at the <code>Opt</code>
structure in <code>main.rs</code> and compare the interface with its
definition.</p>


<div class="box box-shortcode question" >
    <span class="icon-box baseline">
      <svg><use href="#question-box"></use></svg>
    </span>
    <p>What happens when a flag&rsquo;s input is invalid? (invalid)</p>
<p>Try passing in some invalid values for flags. For instance,
it should not be possible to set <code>-f</code> to <code>idk</code>. How does
<code>structopt</code> know to reject invalid values?</p>
  </div>

<p>You&rsquo;ll notice that there are plenty of options. All of these
correspond to settings available on a serial device. For now it&rsquo;s
not important to know exactly what these settings do.</p>
<h4 id="talking-to-a-serial-device">Talking to a Serial Device</h4>
<p>In <code>main</code>, you&rsquo;ll see a call to
<a href="https://docs.rs/serial/0.4.0/serial/fn.open.html"  target="_blank" rel="noreferrer nofollow">serial::open</a>
.
This is calling the <code>open</code> function from the
<a href="https://docs.rs/serial/0.4.0/serial/"  target="_blank" rel="noreferrer nofollow">serial</a>
 crate, also on
<a href="https://crates.io/"  target="_blank" rel="noreferrer nofollow">crates.io</a>
. This <code>open</code> function returns
a
<a href="https://docs.rs/serial-unix/0.4.0/serial_unix/struct.TTYPort.html"  target="_blank" rel="noreferrer nofollow">TTYPort</a>

which allows you to read and write to the serial device (via its
<code>io::Read</code> and <code>io::Write</code> trait implementations) as well as
read and set settings on a serial device (via its <code>SerialDevice</code>
trait implementation).</p>
<h4 id="writing-the-code">Writing the Code</h4>
<p>Implement the <code>ttywrite</code> utility. Your implementation should set
all of the appropriate settings passed in via the command-line
stored in the <code>opt</code> variable in <code>main</code>. It should read from
<code>stdin</code> if no input file is passed in or from the input file if
one is passed in. It should write the input data to the passed in
serial device. If the <code>-r</code> flag is set, it should send the data
as it is. Otherwise, you should use your <code>xmodem</code> implementation
from the previous subphase to send the data using the XMODEM
protocol. You should print the number of bytes sent on a
successful transmission.</p>
<p>To transmit using the XMODEM protocol, your code should use either
the <code>Xmodem::transmit</code> or <code>Xmodem::transmit_with_progress</code>
methods from the <code>xmodem</code> library. We recommend using
<code>transmit_with_progress</code> so that your utility indicates progress
throughput the transmission. In its simplest form, this might look
as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#c6a0f6">fn</span> <span style="color:#8aadf4">progress_fn</span>(progress: <span style="color:#eed49f">Progress</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#8aadf4">println!</span>(<span style="color:#a6da95">&#34;Progress: </span><span style="color:#a6da95">{:?}</span><span style="color:#a6da95">&#34;</span>, progress);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Xmodem::transmit_with_progress(data, to, progress_fn)
</span></span></code></pre></div><p>You can test the baseline correctness of your implementation using
the <code>test.sh</code> script in the <code>ttywrite</code> directory. When your
implementation is at least somewhat correct, you will see the
following when the script is run:</p>
<div class="highlight"><pre tabindex="0" style="color:#cad3f5;background-color:#24273a;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>Opening PTYs...
</span></span><span style="display:flex;"><span>Running <span style="color:#91d7e3">test</span> 1/10.
</span></span><span style="display:flex;"><span>wrote <span style="color:#f5a97f">333</span> bytes to input
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>Running <span style="color:#91d7e3">test</span> 10/10.
</span></span><span style="display:flex;"><span>wrote <span style="color:#f5a97f">232</span> bytes to input
</span></span><span style="display:flex;"><span>SUCCESS
</span></span></code></pre></div>

<div class="box box-shortcode tip" >
    <span class="icon-box baseline">
      <svg><use href="#tip-box"></use></svg>
    </span>
    <p>You can retrieve a handle to <code>stdin</code> with
<a href="https://doc.rust-lang.org/nightly/std/io/fn.stdin.html"  target="_blank" rel="noreferrer nofollow">io::stdin()</a>
.</p>
  </div>



<div class="box box-shortcode tip" >
    <span class="icon-box baseline">
      <svg><use href="#tip-box"></use></svg>
    </span>
    <p>You may find the
<a href="https://doc.rust-lang.org/nightly/std/io/fn.copy.html"  target="_blank" rel="noreferrer nofollow">io::copy()</a>

function useful.</p>
  </div>



<div class="box box-shortcode tip" >
    <span class="icon-box baseline">
      <svg><use href="#tip-box"></use></svg>
    </span>
    <p>The <code>main()</code> function in our reference implementation
is roughly 35 lines of code.</p>
  </div>



<div class="box box-shortcode tip" >
    <span class="icon-box baseline">
      <svg><use href="#tip-box"></use></svg>
    </span>
    <p>Keep the
<a href="https://docs.rs/serial-unix/0.4.0/serial_unix/struct.TTYPort.html"  target="_blank" rel="noreferrer nofollow">TTYPort</a>

documentation open while writing your code.</p>
  </div>



<div class="box box-shortcode question" >
    <span class="icon-box baseline">
      <svg><use href="#question-box"></use></svg>
    </span>
    <p>Why does the <code>test.sh</code> script always set <code>-r</code>? (bad-tests)</p>
<p>The <code>test.sh</code> script that we have provided always uses the
<code>-r</code> flag; it doesn&rsquo;t test that your utility uses the
XMODEM protocol when it is asked to. Why might that be? What
does the XMODEM protocol expect that sending data in the raw
doesn&rsquo;t that makes testing its functionality difficult?</p>
  </div>

<h4 id="installing-ttywrite-utility">Installing <code>ttywrite</code> utility</h4>
<p>After finish writing the <code>ttywrite</code> utility,
install the tool with <code>cargo install --path . --locked</code> command.
This command will be used later
to communicate with the bootloader.</p>
</main>




<br>

<footer>

<script defer>
  document.addEventListener("keydown", function (e) {
    if (document.activeElement.isContentEditable) {
      return false;
    }
    if (document.activeElement.tagName == "INPUT") {
      return false;
    }
    if (e.altKey || e.ctrlKey || e.shiftKey) {
      return false;
    }
    var key = e.key;
    if (key === "h") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/";
    } else if (key === "t") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = `https://${location.hostname}/tags`;
    } else if (key === "i") {
      e.preventDefault();
      e.stopPropagation();
      const inputs = document.querySelectorAll("input");
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].offsetParent !== null) {
          inputs[i].selectionStart = inputs[i].selectionEnd =
            inputs[i].value.length;
          inputs[i].focus();
          break;
        }
      }
    }
    return false;
  });
</script>


<script defer>
  function throttle(fn, wait) {
    var time = Date.now();
    return function () {
      var now = Date.now()
      if (time + wait - now < 0) {
        fn();
        time = now;
      }
    };
  }

  function scrollHandler() {
    const anchors = Array.from(document.querySelectorAll("body h2, body h3"));

    function scrollCallback() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      
      for (var i = 0; i < anchors.length; i++) {
        var anchorId = anchors[i].getAttribute("id");
        var link = document.querySelector(
          'nav ul li a[href="#' + anchorId + '"]',
        );
        if (link) {
          link.classList.remove("active-toc");
        }
      }

      
      for (var i = anchors.length - 1; i >= 0; i--) {
        var offsetTop = anchors[i].offsetTop;
        if (scrollTop > offsetTop - 75) {
          var anchorId = anchors[i].getAttribute("id");
          var link = document.querySelector(
            'nav ul li a[href="#' + anchorId + '"]',
          );
          if (link) {
            link.classList.add("active-toc");
            break;
          }
        }
      }
    }

    window.addEventListener(
      "scroll",
      throttle(scrollCallback, 300),
    );
  }
  setTimeout(scrollHandler, 100);
</script>

<script defer>
  function addCopyButtonToCodeBlocks() {
    
    const codeBlocks = document.querySelectorAll('code[class^="language-"]');

    codeBlocks.forEach((codeBlock) => {
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-code-button");
      copyButton.innerHTML = "copy";

      
      copyButton.addEventListener("click", () => {
        
        const elements = codeBlock.querySelectorAll(".cl");
        let codeToCopy = "";
        elements.forEach((element) => {
          codeToCopy += element.innerText;
        });
        navigator.clipboard.writeText(codeToCopy);

        
        copyButton.innerHTML = "copied!";
        setTimeout(() => {
          copyButton.innerHTML = "copy";
        }, 1500);
      });

      
      codeBlock.parentNode.before(copyButton);
    });
  }
  setTimeout(function () {
    addCopyButtonToCodeBlocks();
  }, 100);
</script>

<script>
window.store = {
    
    "\/post\/": {
        "title": "Posts",
        "tags": [],
        "content": "", 
        "url": "\/post\/"
    },
    
    "\/tags\/lab\/": {
        "title": "Lab",
        "tags": [],
        "content": "", 
        "url": "\/tags\/lab\/"
    },
    
    "\/post\/lab3\/": {
        "title": "Lab 3: Shell and Bootloader Phase 1",
        "tags": ["Lab",],
        "content": "Introduction In this assignment, you will write useful utilities, libraries, and a simple shell for Raspberry Pi. This is just a single phase of this exercise and we\u0026rsquo;ll be going over the rest of them in the incoming weeks.\nPlease insure you\u0026rsquo;ve setup the environment as described on Tools page .\nThis is the directory structure of our repository. The directories you will be working on this lab section are marked with *.\n. ├── bin : common binaries/utilities ├── ext : external files (e.g., resources for testing) ├── boot : bootloader * ├── kern : the main os kernel * └── lib : required libraries ├── pi * ├── shim ├── stack-vec * ├── ttywrite * ├── volatile * └── xmodem * We recommend the following directory structure for your assignments. Confirm that your directories are properly laid out by running make inside the kern directory now. If all is well, the command will return successfully. If everything is good, feel free to explore the contents of the repository.\nPhase 1: Oxidation In this phase, you will write two libraries, one command-line utility, and review one library. You will be working in the stack-vec, volatile, ttywrite, and xmodem skeleton subdirectories located in lib directory.\nAll projects are being managed with Cargo. You will find the following cargo commands useful:\ncargo build - build an application or library cargo test - test an application or library cargo run - run an application cargo run -- $flags - run an application and pass arbitrary flags to it For more information on using Cargo and how Cargo works, see the Cargo Book .\nSubphase A: StackVec One important facility that operating systems provide is memory allocation. When a C, Rust, Java, Python, or just about any application calls malloc() and malloc() has run out of memory from the operating system, a system call is eventually made to request additional memory. The operating system determines if there is memory available, and if so, fulfills the request for memory.\nMemory allocation is a complicated story.\nIn practice, modern operating systems like Linux have a complicated relationship with memory allocation. For instance, as an optimization, most requests for memory allocation are only \u0026ldquo;virtually\u0026rdquo; handled: no physical memory is actually allocated until the application tries to use the newly allocated memory. Nonetheless, most operating systems aim to provide the illusion that they are allocating memory in the simplistic manner we\u0026rsquo;ve described. Operating systems are master liars.\nHeap-allocated structures like Vec, String, and Box internally call malloc() to allocate memory as necessary. This means that these structures require operating system support to function. In particular, they require the operating system to support memory allocation. We haven\u0026rsquo;t yet started writing our operating system, so clearly there\u0026rsquo;s no memory allocation support for our tiny bare-metal programs to make use of. As such, we can\u0026rsquo;t use heap-allocated structures like Vec until our operating system is further along.\nThis is a real shame because Vec is a nice abstraction! It allows us to think about pushing and poping elements without having to keep track of memory ourselves. How we can get the benefits of the Vec abstraction without supporting memory allocation?\nOne common technique is to pre-allocate memory and then hand that memory to a structure to abstract away. Some ways to pre-allocate memory include using static declarations to set apart memory in the static section of a binary or through stack allocations from local variable declarations. In any case, the allocations is of a fixed, predetermined size.\nIn this subphase, you will implement the StackVec structure, a structure that exposes a Vec-like API when given pre-allocated memory. You will use the StackVec type later in phase 2 when implementing a shell for your Raspberry Pi. You will work in the lib/stack-vec skeleton subdirectory. The subdirectory contains the following files:\nCargo.toml - configuration file for Cargo src/lib.rs - where you will write your code src/tests.rs - tests that will run when cargo test is called The StackVec Interface A StackVec\u0026lt;T\u0026gt; is created by calling StackVec::new(), passing in a mutable slice to values of any type T. The StackVec\u0026lt;T\u0026gt; type implements many of the methods that Vec implements and is used in much the same way. Here\u0026rsquo;s an example of a StackVec\u0026lt;u8\u0026gt; being used:\nlet mut storage = [0u8; 10]; let mut vec = StackVec::new(\u0026amp;mut storage); for i in 0..10 { vec.push(i * i).expect(\u0026#34;can push 10 times\u0026#34;); } for (i, v) in vec.iter().enumerate() { assert_eq!(*v, (i * i) as u8); } let last_element = vec.pop().expect(\u0026#34;has elements\u0026#34;); assert_eq!(last_element, 9 * 9); We\u0026rsquo;ve declared the StackVec structure for you already:\npub struct StackVec\u0026lt;\u0026#39;a, T: \u0026#39;a\u0026gt; { storage: \u0026amp;\u0026#39;a mut [T], len: usize } Understanding StackVec The following questions test your understanding about the StackVec interface:\nWhy does push return a Result? (push-fails)\nThe push method from Vec in the standard library has no return value, but the push method from our StackVec does: it returns a Result indicating that it can fail. Why can StackVec::push() fail where Vec::push() does not?\nWhy is the 'a bound on T required? (lifetime)\nstruct StackVec\u0026lt;\u0026#39;a, T\u0026gt; { buffer: \u0026amp;\u0026#39;a mut [T], len: usize } Rust automatically enforces the bound T: 'a and will complain if type T lives shorter than the lifetime 'a. For instance, if T is \u0026amp;'b str and 'b is strictly shorter than 'a, Rust won\u0026rsquo;t allow you to create the instance of StackVec\u0026lt;'a, \u0026amp;'b str\u0026gt;.\nWhy is the bound required? What could go wrong if the bound wasn\u0026rsquo;t enforced by Rust?\nWhy does StackVec require T: Clone to pop()? (clone-for-pop)\nThe pop method from Vec\u0026lt;T\u0026gt; in the standard library is implemented for all T, but the pop method from our StackVec is only implemented when T implements the Clone trait. Why might that be? What goes wrong when the bound is removed?\nImplementing StackVec Implement all of the unimplemented!() StackVec methods in stack-vec/src/lib.rs. Each method is documented in the source code. We have also provided tests in src/tests.rs that help ensure that your implementations are correct. You can run these tests with cargo test. You\u0026rsquo;ll also need to implement the Deref, DerefMut, and IntoIterator traits for StackVec as well as the IntoIterator trait for \u0026amp;StackVec for all of the cargo test tests to pass. Once you feel confident that you implementation is correct and have answered this subphase\u0026rsquo;s questions, proceed to the next subphase.\nWhich tests make use of the Deref implementations? (deref-in-tests)\nRead through the tests we have provided in src/tests.rs. Which tests would fail to compile if the Deref implementation did not exist? What about the DerefMut implementation? Why?\nOur unit tests are incomplete!\nOur unit tests provide a baseline truth, but they are not complete! We will run additional tests when we grade your assignment. You may wish to find the gaps in our tests and add additional tests of your own to fill them.\nSubphase B: volatile In this subphase, you will learn about volatile memory accesses, read the source code in the volatile skeleton subdirectory, and answer questions related to the source code. You won\u0026rsquo;t be writing any code in this subphase.\nLike operating systems, compilers are masters at making things appear as if they\u0026rsquo;re doing what you think they\u0026rsquo;re doing when in reality, they\u0026rsquo;re really doing something entirely different for the sake of optimization. One such optimization is dead-access elimination: compilers remove memory accesses (reads and writes) when they can prove doing so has no observable effect on the program\u0026rsquo;s execution. For instance, consider the following program:\nfn f() { let mut x = 0; let y = \u0026amp;mut x; *y = 10; } The compiler can completely eliminate the write to *y by reasoning that *y is never read after it\u0026rsquo;s written. The compiler concludes that as a result, the write cannot possibly effect the program, and eliminates it in the compiled binary. For the same reason, it can then proceed to eliminate the declaration for y, the declaration for x, and calls to f() entirely.\nThese kinds of optimizations are almost exclusively beneficial: they speed up our programs without affecting their outcome. But sometimes these optimizations can have unintended consequences. Say, for example, that y was pointing to a write-only memory-mapped register. Then, writes to *y will have observable effects without having to read *y thereafter. If the compiler is not aware of this, it will optimize away these writes, and our program will not function correctly.\nHow can we force the compiler to keep around reads and writes that appear to have no effects at the source code level? This is where volatile memory accesses come in: the compiler promises not to optimize away volatile memory accesses. So if we want to ensure a read or write occurs at runtime, we must perform a volatile memory access.\nRusty volatile In Rust, we use the read_volatile and write_volatile methods to perform volatile reads and writes to a raw pointer.\nWhat\u0026rsquo;s a raw pointer?\nBy now you\u0026rsquo;re familiar with references (\u0026amp;T and \u0026amp;mut T). A raw pointer in Rust (*const T and *mut T) is a \u0026ldquo;reference\u0026rdquo; that isn\u0026rsquo;t tracked with lifetimes by Rust\u0026rsquo;s borrow checker. Because of this, read or writes to these pointers may be invalid, just as in C. Rust considers them unsafe, and code that reads or writes them must be annotated with unsafe to indicate this. You can read more about raw pointers in the rustdocs .\nCalling read_volatile and write_volatile every time we want to perform a volatile read or write is error prone and frustrating. Thankfully Rust provides us the tools to make this easier and safer. Ideally we can simply declare a pointer as volatile (as in C) and ensure that every read or write thereafter is volatile. Even better, we should be able declare a pointer as read-only, write-only (unlike in C), or read/write and ensure only the appropriate memory accesses can be made.\nIntroducing Volatile, ReadVolatile, WriteVolatile, and UniqueVolatile The volatile crate in the volatile/ skeleton subdirectory implements these four types that allow us to do just this. Read the documentation for these types now by running cargo doc --open inside of the volatile/ directory.\nWhy does Unique\u0026lt;Volatile\u0026gt; exist? (unique-volatile)\nBoth Volatile and Unique\u0026lt;Volatile\u0026gt; allow read/write volatile accesses to an underlying pointer. According to the documentation, what is the difference between these two types?\nNow open the source code in src/lib.rs, src/traits.rs, and src/macros.rs. Read through the source code to the best of your abilities. When you\u0026rsquo;re ready, answer the following questions. Once you have answered these questions, you\u0026rsquo;re ready to move on to the next subphase.\nWhat\u0026rsquo;s with #[repr(C)]?\nThe #[repr(C)] annotation forces Rust to lay out the structure\u0026rsquo;s fields in the same way that C would. In general, Rust optimizes the order and padding between fields of structures in an unspecified way. When we cast a raw address to a pointer to a structure, we typically have a very specific memory layout in mind. The #[repr(C)] annotation lets us confide that Rust will arrange the structure as we intend it to, not as it wishes.\nHow are read-only and write-only accesses enforced? (enforcing)\nThe ReadVolatile and WriteVolatile types make it impossible to write and read, respectively, the underlying pointer. How do they accomplish this?\nWhat do the macros do? (macros)\nWhat do the readable!, writeable!, and readable_writeable! macros do?\nSubphase C: xmodem In this subphase, you will implement the XMODEM file transfer protocol in the xmodem library in the xmodem/ skeleton subdirectory. You will primarily be working in xmodem/src/lib.rs.\nXMODEM is a simple file transfer protocol originally developed in 1977. It features packet checksums, cancellation, and automatic retries. It is widely implemented and used for transfers through serial interfaces. Its best feature, however, is its simplicity. For more about its history, see the XMODEM Wikipedia article .\nWe will use the XMODEM protocol to transfer files to the Raspberry Pi. While we could use existing implementations of the XMODEM protocol to send data to the Pi, we will still need to write our own receiver. So, while we\u0026rsquo;re at it, we\u0026rsquo;ll be implementing XMODEM transmission as well.\nThe Protocol The XMODEM protocol is described in detail in the Understanding The X-Modem File Transfer Protocol txt file. We describe it again here, for posterity.\nDo not base your implementation off of Wikipedia\u0026rsquo;s explanation!\nWhile Wikipedia\u0026rsquo;s explanation is helpful at a high level, many of the details presented there are different from the protocol we\u0026rsquo;ll be implementing here. As such, do not use the article as a reference for this subphase.\nXMODEM is a binary protocol: bytes are sent and received in the raw. It is also \u0026ldquo;half duplex\u0026rdquo;: at any point in time, either the sender or receiver is sending data, but never both. Finally it is packet-based: data is separated into 128 byte chunks known as packets. The protocol dictates which bytes are sent when, what they mean, and how they\u0026rsquo;re interpreted.\nFirst, we define a few constants:\nconst SOH: u8 = 0x01; const EOT: u8 = 0x04; const ACK: u8 = 0x06; const NAK: u8 = 0x15; const CAN: u8 = 0x18; To start the file transfer, the receiver sends a NAK byte while the sender waits for a NAK byte. Once the sender has received the NAK byte, packet transmission begins. The receiver only sends a NAK byte to begin the file transfer, not once for every packet.\nOnce file transfer has begun, each packet\u0026rsquo;s transmission and reception is identical. Packets are numbered in sequential order starting at 1 and wrap around to 0 after 255.\nXMODEM protocol diagram To send a packet, the sender:\nSends an SOH byte.\nSends the packet number.\nSends the 1s complement of the packet number (255 - $packet_number).\nSends the packet itself.\nSends the packet checksum.\nThe checksum is the sum of all of the bytes in the packet mod 256. Reads a byte from the receiver.\nIf the byte is NAK, transmission for the same packet is retried up to 10 times. If the byte is ACK, the next packet is sent. The receive a packet, the receiver performs the inverse:\nWaits for an SOH or EOT byte from the sender.\nIf a different byte is received, the receiver cancels the transfer. If an EOT byte is received, the receiver performs end of transmission. Reads the next byte and compares it to the current packet number.\nIf the wrong packet number is received, the receiver cancels the transfer. Reads the next byte and compares it to the 1s complement of the packet number.\nIf the wrong number is received, the receiver cancels the transfer. Reads a packet (128 bytes) from the sender.\nComputes the checksum for the packet.\nThe checksum is the sum of all of the bytes in the packet mod 256. Reads the next byte and compares it to the computed checksum.\nIf the checksum differs, sends a NAK byte and retries reception for the same packet. If the checksum is the same, sends an ACK byte and receives the next packet. To cancel a transfer, a CAN byte is sent by either the receiver or sender. When either side receives a CAN byte, it errors out, aborting the connection.\nTo end the transmission, the sender:\nSends an EOT byte. Waits for a NAK byte. If a different byte is received, the sender errors out. Sends a second EOT byte. Waits for an ACK byte. If a different byte is received, the sender errors out. To end the transmission, the receiver performs the following after receiving the first EOT:\nSends a NAK byte. Waits for a second EOT byte. If a different byte is received, the receiver cancels the transfer. Sends an ACK byte. Implementing XMODEM We have provided an unfinished implementation of the XMODEM protocol in the xmodem skeleton subdirectory. Your task is to complete the implementation by writing the expect_byte, expect_byte_or_cancel, read_packet, and write_packet methods in src/lib.rs. Your implementations should make use of the internal state of the Xmodem type: packet and started. We recommend reading over the existing code before starting.\nYou should begin by implementing the expect_byte and expect_byte_or_cancel methods. You should then make use of all four of the helper methods (including read_byte and write_byte) to implement read_packet and write_packet. To see how these methods are used, read the transmit and receive implementations which transmit or receive a complete data stream using XMODEM via these methods. Be mindful of the specifications in the doc-comments. You can test your implementation using cargo test. Once you are confident that your implementation is correct, proceed to the next subphase.\nDo not use any additional items from std.\nYour implementation should only use items from shim::io. It should not use other items from std or any other libraries.\nOur reference implementations for {read,write}_packet are roughly 43 lines of code each.\nThe io::Read and io::Write rustdocs will be useful.\nUse the ? operator generously.\nThe test source code can be a helpful guide.\nYou can use ioerr! macro to make and return a new io::Error easily. Please refer shim/src/macros.rs to find more macros which can be useful.\nSubphase D: ttywrite In this subphase, you will write a command line utility, ttywrite, that will allow you to send data to your Raspberry Pi in the raw or via the XMODEM protocol. You will use your xmodem library from the previous subphase in your implementation. You will write your code in ttywrite/src/main.rs. To test your ttywrite implementation, use the provided test.sh script.\nWhat is a serial device?\nA serial device is any device that accepts communication one bit at a time. This is known as serial communication. In contrast, in parallel communication multiple bits are being transferred at any point in time in parallel. We will be communicating with our Raspberry Pi via its UART device, a serial communication device.\nWhat is a TTY?\nA TTY is a \u0026ldquo;teletypewriter\u0026rdquo;. It is a vestigial term that was adopted in computing to describe computer terminals. The term later become more general, coming to describe any device intended to be communicated with over serial. For this reason, your computer calls the device mapping to your Raspberry Pi a TTY.\nCommand-Line Interface The skeleton code we have provided for ttywrite already parses and validates command-line arguments. To do so, it uses the structopt crate from crates.io which itself uses clap . You\u0026rsquo;ll notice that we list it as a dependency in the Cargo.toml file. structopt works through code generation. We simply annotate a structure and its fields with a declaration of our command-line arguments and structopt generates the code to actually parse the command-line flags.\nTo see the interface that structopt generates, call the application with --help. Remember that you can pass arbitrary flags when using cargo run: cargo run -- --help. Take a look at the interface now. Then, take a look at the Opt structure in main.rs and compare the interface with its definition.\nWhat happens when a flag\u0026rsquo;s input is invalid? (invalid)\nTry passing in some invalid values for flags. For instance, it should not be possible to set -f to idk. How does structopt know to reject invalid values?\nYou\u0026rsquo;ll notice that there are plenty of options. All of these correspond to settings available on a serial device. For now it\u0026rsquo;s not important to know exactly what these settings do.\nTalking to a Serial Device In main, you\u0026rsquo;ll see a call to serial::open . This is calling the open function from the serial crate, also on crates.io . This open function returns a TTYPort which allows you to read and write to the serial device (via its io::Read and io::Write trait implementations) as well as read and set settings on a serial device (via its SerialDevice trait implementation).\nWriting the Code Implement the ttywrite utility. Your implementation should set all of the appropriate settings passed in via the command-line stored in the opt variable in main. It should read from stdin if no input file is passed in or from the input file if one is passed in. It should write the input data to the passed in serial device. If the -r flag is set, it should send the data as it is. Otherwise, you should use your xmodem implementation from the previous subphase to send the data using the XMODEM protocol. You should print the number of bytes sent on a successful transmission.\nTo transmit using the XMODEM protocol, your code should use either the Xmodem::transmit or Xmodem::transmit_with_progress methods from the xmodem library. We recommend using transmit_with_progress so that your utility indicates progress throughput the transmission. In its simplest form, this might look as follows:\nfn progress_fn(progress: Progress) { println!(\u0026#34;Progress: {:?}\u0026#34;, progress); } Xmodem::transmit_with_progress(data, to, progress_fn) You can test the baseline correctness of your implementation using the test.sh script in the ttywrite directory. When your implementation is at least somewhat correct, you will see the following when the script is run:\nOpening PTYs... Running test 1/10. wrote 333 bytes to input ... Running test 10/10. wrote 232 bytes to input SUCCESS You can retrieve a handle to stdin with io::stdin() .\nYou may find the io::copy() function useful.\nThe main() function in our reference implementation is roughly 35 lines of code.\nKeep the TTYPort documentation open while writing your code.\nWhy does the test.sh script always set -r? (bad-tests)\nThe test.sh script that we have provided always uses the -r flag; it doesn\u0026rsquo;t test that your utility uses the XMODEM protocol when it is asked to. Why might that be? What does the XMODEM protocol expect that sending data in the raw doesn\u0026rsquo;t that makes testing its functionality difficult?\nInstalling ttywrite utility After finish writing the ttywrite utility, install the tool with cargo install --path . --locked command. This command will be used later to communicate with the bootloader.\n", 
        "url": "\/post\/lab3\/"
    },
    
    "\/tags\/": {
        "title": "Tags",
        "tags": [],
        "content": "", 
        "url": "\/tags\/"
    },
    
    "\/post\/env_setup\/": {
        "title": "Tools",
        "tags": ["Lab",],
        "content": "Setting up the environment Before starting to this series of lab assignments, please make sure that you have followed the environment setup described below.\nOur labs are designed based on Ubuntu 20.04 LTS. This is done using docker so that everyone has similar setups.\nWe recommend you to stick to this ubuntu version unless you might face some configuration issues.\nYou will also be using use QEMU, an x86 emulator for easier executing and debugging process instead of using real raspberry pi board.\nThis section has the information you’ll need to setup the environment.\nDocker You may install Ubuntu 20.04 on WSL and skip to the next part .\nYou first need to install docker for your OS:\nWindows Mac Linux Spin up Container Please ensure that your installation location for Docker has atleast 10GB of free space.\nGo to your working directory where you\u0026rsquo;ll be working inside and run:\ndocker run -it --name os_labs -v $(pwd):/root/workdir:Z ubuntu:20.04 Now you\u0026rsquo;ll be inside the container, where you\u0026rsquo;ll see a prompt like this:\nroot@e8f10931f506:/# Your working directory will now be available in /root/workdir/.\nFor resuming the container after you\u0026rsquo;ve exited:\ndocker start -i os_labs Anyone with SELINUX enabled distros like Fedora may face some problems with shared dirs between the host and the containers. Please contact the TAs if you get stuck somewhere.\nGetting Repository and Installing Dependencies Please ensure that whatever directory you decide to keep the lab in, it has atleast 10GB of free space.\n# Download the repository git clone https://github.com/pratyush3757/cs330_os.git --origin skeleton rustos cd rustos/ git switch lab3 # Install dependencies ./bin/setup.sh # Update environment source ~/.bashrc You\u0026rsquo;re all set to go back to the lab document if the setup.sh runs correctly and says [!] Setup complete.\nContact a TA if it throws an error.\nReference This section has the information for the various tools you\u0026rsquo;ll be using during the labs.\nWe will be updating this section with more required info as the labs go on.\nMakefile Our Makefile includes a number of targets to test and run our OS in various ways.\nmake Build kernel in release mode. The result executable and binary will be located under build/ subdirectory. make debug Build Rust libraries or kernel in debug mode. make check Check a local package and all of its dependencies for errors. make qemu Start QEMU with the executable file under build/ subdirectory generated by make command. QEMU will generate a detailed log of assembly code of the guest. To exit QEMU, press Ctrl-a x. make objdump Disassemble the executable file generated by make. make nm List all symbols in the executable file generated by make. make clean Clean the directory. make install Install compiled kernel image to SD card. (Not needed until we have physical RPi devices) make test Execute all unit and integration tests and build examples of a local package. QEMU Emulator QEMU (manual ) is a modern and fast PC emulator. We are providing a pre-built QEMU binary to emulate raspberry pi 3+ board as /bin/qemu-system-aarch64.\nQEMU includes a built-in monitor that can inspect and modify the machine state in useful ways. To enter the monitor, press Ctrl-a c in the terminal running QEMU. Press Ctrl-a c again to switch back to the serial console.\nFor a complete reference to the monitor commands, see the QEMU manual . Here are some particularly useful commands:\nxp/Nx paddr Display a hex dump of N words starting at physical address paddr. If N is omitted, it defaults to 1. This is the physical memory analogue of GDB’s x command. info registers Display a full dump of the machine’s internal register state. In particular, this includes the machine’s hidden segment state for the segment selectors and the local, global, and interrupt descriptor tables, plus the task register. This hidden state is the information the virtual CPU read from the GDT/LDT when the segment selector was loaded. info mem Display mapped virtual memory and permissions. For example, ef7c0000-ef800000 00040000 urw efbf8000-efc00000 00008000 -rw tells us that the 0x00040000 bytes of memory from 0xef7c0000 to 0xef800000 are mapped read/write and user-accessible, while the memory from 0xefbf8000 to 0xefc00000 is mapped read/write, but only kernel-accessible. ", 
        "url": "\/post\/env_setup\/"
    },
    
    "\/": {
        "title": "",
        "tags": [],
        "content": " ", 
        "url": "\/"
    },
    
    "\/categories\/": {
        "title": "Categories",
        "tags": [],
        "content": "", 
        "url": "\/categories\/"
    },
    
}
</script>
<script defer src="/js/lunr.js"></script>
<script defer src="/js/search.js"></script>

</footer>

</body>
</html>

